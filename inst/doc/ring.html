<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Rich FitzJohn" />

<meta name="date" content="2017-04-24" />

<title>ring</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">ring</h1>
<h4 class="author"><em>Rich FitzJohn</em></h4>
<h4 class="date"><em>2017-04-24</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#the-environment-buffer-ring_buffer_env">The environment buffer <code>ring_buffer_env</code></a><ul>
<li><a href="#application-simulation-with-recent-history">Application: simulation with recent history</a></li>
</ul></li>
<li><a href="#the-bytes-buffer-ring_buffer_bytes">The bytes buffer <code>ring_buffer_bytes</code></a><ul>
<li><a href="#striding">Striding</a></li>
<li><a href="#the-typed-bytes-buffer-ring_buffer_bytes_typed">The typed bytes buffer <code>ring_buffer_bytes_typed</code></a></li>
<li><a href="#the-translating-bytes-buffer-ring_buffer_bytes_translate">The translating bytes buffer <code>ring_buffer_bytes_translate</code></a></li>
</ul></li>
<li><a href="#the-c-api">The C API</a><ul>
<li><a href="#a-nontrivial-example">A nontrivial example</a></li>
</ul></li>
<li><a href="#the-c-api-1">The C++ API</a></li>
</ul>
</div>

<p>This package implements <a href="https://en.wikipedia.org/wiki/Ring_buffer">ring buffers</a>. A ring buffer can be used as a first-in-first-out (FIFO) buffer where the maximum size is known ahead of time. Because they do not grow in size, they are useful to avoid using more and more memory as a process runs. Because the data reading and writing happens in an (apparently) circular way, once data is added to the buffer it is not copied (in contrast if you used a vector then every time data is consumed you’d have to shuffle the vector around).</p>
<p><code>ring</code> implements two different ring buffers that will likely suit different applications.</p>
<ul>
<li><code>ring_buffer_bytes</code> is imlemented as a byte array in C, possibly with a “stride” indicating a set of bytes that go together. Once the data reaches the end of the array we start writing to the beginning again.</li>
<li><code>ring_buffer_env</code> is implemented as a doubly linked list using R’s environments. This buffer can hold arbitrary R objects at each position.</li>
</ul>
<p>The target audience for this package is either other package developers who need a ring buffer in their package, or modellers who have decided that a ring buffer is the right data structure to help with their simulation model.</p>
<p>For all buffers, <code>head</code> will refer to the next bit of the buffer to be written to, and <code>tail</code> will refer to the next bit of the buffer to be read. That is, elements are pushed onto the <code>head</code> of the buffer and retrieved from the <code>tail</code>. (There is no direct analogy between these termas and the R functions <code>head</code> and <code>tail</code> which operate on fixed-size vectors.)</p>
<div id="the-environment-buffer-ring_buffer_env" class="section level1">
<h1>The environment buffer <code>ring_buffer_env</code></h1>
<p>This is the simplest buffer to understand because we don’t have to deal with raw vectors.</p>
<p>To create a buffer that can hold up to 100 elements, use the <code>ring_buffer_env</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_env</span>(<span class="dv">100</span>)</code></pre></div>
<p>This is an <a href="https://github.com/wch/R6">R6</a> class, with several methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf</code></pre></div>
<pre><code>## &lt;Ring Buffer (ring_buffer_env)&gt;
##   Public:
##     copy: function (dest, n)
##     duplicate: function ()
##     free: function ()
##     grow: function (n)
##     head: function ()
##     head_advance: function ()
##     head_data: function ()
##     head_offset: function (n)
##     head_pos: function ()
##     head_set: function (data)
##     is_empty: function ()
##     is_full: function ()
##     mirror: function (dest)
##     push: function (data, iterate = TRUE)
##     read: function (n)
##     read_head: function (n)
##     reset: function (clear = FALSE)
##     set: function (data, n)
##     size: function ()
##     tail: function ()
##     tail_offset: function (n)
##     tail_pos: function ()
##     take: function (n)
##     take_head: function (n)
##     used: function ()</code></pre>
<p>Operations on the class happen by running methods using <code>$</code>. So the size of the buffer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">size</span>()</code></pre></div>
<pre><code>## [1] 100</code></pre>
<p>…the number of elements free and used:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">free</span>()</code></pre></div>
<pre><code>## [1] 100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>…whether the buffer is empty or full:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_empty</span>()</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_full</span>()</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>To start using the buffer we need to put some data in it. There are two main functions for adding data:</p>
<ul>
<li><code>buf$set(data, n)</code> sets <code>n</code> elements to be the value <code>data</code></li>
<li><code>buf$push(data, iterate)</code> pushes <code>data</code> into the buffer, with the <code>iterate</code> argument indicating if we should iterate over <code>data</code> or treat it as a single element</li>
</ul>
<p>So to set the first 5 elements to be “a”, “b”, …, “e”, use:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(letters[<span class="dv">1</span>:<span class="dv">5</span>])</code></pre></div>
<p>The buffer is no longer empty</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_empty</span>()</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>…having 5 elements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 5</code></pre>
<p>…and room for 95 more:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">free</span>()</code></pre></div>
<pre><code>## [1] 95</code></pre>
<p>To read the content of the buffer without modifying it, use <code>read(n)</code> where <code>n</code> is the number of elements to read. This <em>always</em> returns a list of length <code>n</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">read</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [[1]]
## [1] &quot;a&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">read</span>(<span class="dv">2</span>)</code></pre></div>
<pre><code>## [[1]]
## [1] &quot;a&quot;
## 
## [[2]]
## [1] &quot;b&quot;</code></pre>
<p>If you try to read too far, then the buffer will underflow and you will get an error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">read</span>(<span class="dv">20</span>)</code></pre></div>
<pre><code>## Error: Buffer underflow (requested 20 elements but 5 available)</code></pre>
<p>If you just want the the first element, use <code>tail()</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">tail</span>()</code></pre></div>
<pre><code>## [1] &quot;a&quot;</code></pre>
<p>The tail returns the first element in (so the buffer naturally operates as a first-in-first-out queue).</p>
<p>You can also read the most recently added element with <code>head()</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">head</span>()</code></pre></div>
<pre><code>## [1] &quot;e&quot;</code></pre>
<p>And you can offset these by an integer number of steps. So moving one position into the buffer from the tail gets the second element added:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">tail_offset</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] &quot;b&quot;</code></pre>
<p>or moving three elements into the buffer from the head (most recently added elemnt) gets the same bit of data</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">head_offset</span>(<span class="dv">3</span>)</code></pre></div>
<pre><code>## [1] &quot;b&quot;</code></pre>
<p>The above operations are all nondestructive – they leave the buffer unchanged. To consume elements, use <code>take(n)</code> which operates the same way as <code>read</code> but it also moves the buffer <code>tail</code>; it consumes elements leaving space for more.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">free</span>()</code></pre></div>
<pre><code>## [1] 95</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">take</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [[1]]
## [1] &quot;a&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">free</span>()</code></pre></div>
<pre><code>## [1] 96</code></pre>
<p>Now we have consumed an element the tail has moved along, so <code>tail</code> contains “b” and “a” is removed from the buffer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">tail</span>()</code></pre></div>
<pre><code>## [1] &quot;b&quot;</code></pre>
<p>To reset the buffer, use <code>reset()</code>. This empties the buffer of all data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">reset</span>()
buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_empty</span>()</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>While the ring buffer is fixed in size in typical use, you can grow it explicitly. To add additional space, use the <code>grow</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">size</span>()</code></pre></div>
<pre><code>## [1] 100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">grow</span>(<span class="dv">20</span>)
buf$<span class="kw">size</span>()</code></pre></div>
<pre><code>## [1] 120</code></pre>
<div id="application-simulation-with-recent-history" class="section level2">
<h2>Application: simulation with recent history</h2>
<p>The whole point of the ring buffer though is that we can push things onto it and pull the most recent out, even when the number of things pushed <em>overall</em> is larger than the buffer size.</p>
<p>So imagine a simulation where we need to keep track of the last 5 steps. The simulation is a random walk.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">step &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">runif</span>(<span class="dv">1</span>) &lt;<span class="st"> </span><span class="fl">0.5</span>) x -<span class="st"> </span>1L else x +<span class="st"> </span>1L
}

x &lt;-<span class="st"> </span>0L
buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_env</span>(<span class="dv">5</span>)
h &lt;-<span class="st"> </span><span class="kw">integer</span>(<span class="dv">20</span>)
buf$<span class="kw">push</span>(x)
h[1L] &lt;-<span class="st"> </span>x

<span class="kw">set.seed</span>(<span class="dv">1</span>)
for (i in <span class="kw">seq_len</span>(<span class="kw">length</span>(h) -<span class="st"> </span>1L)) {
  x &lt;-<span class="st"> </span><span class="kw">step</span>(x)
  buf$<span class="kw">push</span>(x)
  h[i +<span class="st"> </span>1L] &lt;-<span class="st"> </span>x
}</code></pre></div>
<p>The whole history:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">h</code></pre></div>
<pre><code>##  [1]  0 -1 -2 -1  0 -1  0  1  2  3  2  1  0  1  0  1  0  1  2  1</code></pre>
<p>The last 5 steps:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unlist</span>(buf$<span class="kw">read</span>(<span class="dv">5</span>))</code></pre></div>
<pre><code>## [1] 1 0 1 2 1</code></pre>
<p>So we could rewrite the simulation so that the random walk tends up if the last few steps have been increases and tends down if the last few steps have been decreases:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">step &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">length</span>(x) &gt;<span class="st"> </span><span class="dv">1</span>) {
    p &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">diff</span>(x)) /<span class="st"> </span><span class="dv">2</span> +<span class="st"> </span><span class="fl">0.5</span>
  } else {
    p &lt;-<span class="st"> </span><span class="fl">0.5</span>
  }
  if (<span class="kw">runif</span>(<span class="dv">1</span>) &lt;<span class="st"> </span>p) x[<span class="kw">length</span>(x)] -<span class="st"> </span>1L else x[<span class="kw">length</span>(x)] +<span class="st"> </span>1L
}

x &lt;-<span class="st"> </span>0L
buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_env</span>(<span class="dv">5</span>)
h &lt;-<span class="st"> </span><span class="kw">integer</span>(<span class="dv">100</span>)
buf$<span class="kw">push</span>(x)
h[1L] &lt;-<span class="st"> </span>x

<span class="kw">set.seed</span>(<span class="dv">1</span>)
for (i in <span class="kw">seq_len</span>(<span class="kw">length</span>(h) -<span class="st"> </span>1L)) {
  x &lt;-<span class="st"> </span><span class="kw">step</span>(<span class="kw">unlist</span>(buf$<span class="kw">read</span>(buf$<span class="kw">used</span>())))
  buf$<span class="kw">push</span>(x)
  h[i +<span class="st"> </span>1L] &lt;-<span class="st"> </span>x
}</code></pre></div>
<p>Now we have a simulation with a strong mean reverting tendency:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, .<span class="dv">5</span>, .<span class="dv">5</span>))
<span class="kw">plot</span>(h, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;step&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">las =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqAAAAHgCAYAAAB6jN80AAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAABAAElEQVR4AeydCdAmRXnHe+/99j7YDXtwuAYFleKQQy1JTMJRSEJZuRSNsUjUWBJTiamKiVpJBS0rmliJRUXQoiBB4hGlJJooQgWRqKRQIHigRhBYWNbsfd+7X/gP9rfzzdfT/Twz3XO9/67afd9v5pmn//17eqafd46eaePPFsNCAiRAAiRAAiRAAiRAAg0RmN5QPayGBEiABEiABEiABEiABDICTEDZEUiABEiABEiABEiABBolwAS0UdysjARIgARIgARIgARIgAko+wAJkAAJkAAJkAAJkECjBJiANoqblZEACZAACZAACZAACTABZR8gARIgARIgARIgARJolAAT0EZxszISIAESIAESIAESIAEmoOwDJEACJEACJEACJEACjRKY2WhtA6jsb//2b82f/dmfmRNPPHEArWETSIAESIAESIAESCAOgWPHjplzzjnH3HHHHUGHTECDiCYbfO1rXzOf+9znzCte8YrJK/gXCZAACZAACZAACYwwgUOHDpmzzjpLRIAJqAjTcaNp06aZ2bNnm1WrVh1fyG8kQAIkQAIkQAIkMOIENm7caMbGxkQUeA+oCBONSIAESIAESIAESIAEYhFgAhqLJP2QAAmQAAmQAAmQAAmICDABFWGiEQmQAAmQAAmQAAmQQCwCTEBjkaQfEiABEiABEiABEiABEQEmoCJMNCIBEiABEiABEiABEohFYHAJ6Pj4eCw29EMCJEACJEACJEACJJCAwGAS0J/85Cfmne98pzn55JOzSeLf+MY3ml27diVARpckQAIkQAIkQAIkQAJ1CAxmHtCrr77a7N+/33zsYx8zBw4cMO95z3vMZZddZu677746fLgtCZAACZAACZAACZBAZAKDSEDvvPNOc++995pvfetb5rzzzssQYTb+q666yvz4xz82p512WmRsdEcCJEACJEACJEACJFCVwCAS0EsuucQ8/vjj5tRTT53g8H//93/Z91mzZk0s4xcSIAESIAESIAESIIH2CQwiAcXrMW3yuX37dvOVr3zFfOhDHzJXXnnlxPL2UVMBCZAACZAACZAACZAACAwiAc2HEmdDH3jgAbN06VJz3XXX5Vd5v//0pz813/zmN702WIlL+jjbykICJEACJEACJEACJFCNwOAS0E984hNmw4YN5sMf/rA566yzsrOhF1xwQZAOtvmXf/mXoN0TTzxhvvOd7wTthmKAs8uYXQA8QwW2H/jAB8xf/MVfhEyTrYeGr371q+ZVr3pVsjp8jg8fPmxmz55t9uzZY+bPn+8zNTt37jRLliwxR44cMTNmzPDaplp5xx13mMsvv9z0Zfqya665xnz0ox9tVe8555xjcI/597///VRhCfpFP3/LW95iPv7xjwdtaUACJEACXSQwuAT0jDPOMPh34YUXZtMx3XrrrUaSgL70pS81t912WzBGP/dzP2dWrVoVtBuKAc4kz507V9Sc6dOnt5ZI5QXu3bs3/2ej35955pmsPnyGHn7Djx4U3K+8evXq7HvT/2HmiD6VsbExg32wzXLiiSca/NBos6xZs8bMmzevTQmsmwRIgARqERjEPKC4LI4n4fNl4cKFWeJ5//335xfzu5IA7qndtm2baKtjx46JbUUOlUZW5+bNm5VbxjNHMomzmfYhOJ9n3PaBIrH1+amzbsuWLdnmu3fvruOmsW3RH/GvzYJ+ZvtaWzo0+2VbGlkvCZAACfgIDCIB/cxnPpNdRkQiagsO0JgDNHQWytrzs5yAZMDHJUmUNgdmJHIzZ85sNaGDhrVr14o0aGzLo1NvDTTgci4++1DQF21fa0svNEj2iZT69u3b17qGlO2jbxIggeETGEQC+vrXvz67HPWOd7zDfO973zPf/va3zZve9CZz9OjR7P7F4YcxTQvtICs5o4gEZs6cOa0mMjijiDdhtZlMoe6TTjpJpEFjmybCz519lSbMqTRo/Noztm3eZtF2AooXbaBs3bpVg462JEACJNApAoNIQNetW5fdv/nDH/7QnHnmmeb88883Dz/8sLn99tsNHhhgqUYACRLuNZMkdF1JpqTJXzUi4a00HGDbdvKn0RtufXoL6MU9oPb2hfQ1Tq4BD2vhLD9uWcAtJ20UtH3FihWi/bINfayTBEiABCQEBvMQ0qWXXppNj7R+/frsHjwM7Cz1CGCgQ0L36KOPBh3ZZAqzBLRVbDK1cePGtiRkSYE0CbZ68dlW6YIGTduhF7fV4PP5z3++ZtMotjjriJkLcJ8vrgy08UCUjdmPfvSjKG2iExIgARJog8AgzoBacLiX7ZRTTsnOKtll/KxOAAMdEnlccsTtDL5iB8W2zkxBm9WLz7aKRoNl1rZeacLcFlNb78GDBw3ufZSelbfbxfxErJB04l9bcUO9mDUB+yR4sJAACZBAHwkMKgHtYwC6rBkDHaacOeGEE8ymTZu8Uu2giDNDbT1RDQ1tJ1MaDRpbL/waK6Gh7dsApPKhtQvJX1c0YN9s8wefNG60IwESIAEXASagLipclhHQDPga21R4bTKFe/RCZ2xTapAmwVYvPtsoeJocE+YzAZXT70o/bzsJlhOjJQmQAAm4CTABdXPh0mcJaAZbnInBGZm2L01Cw/Lly7P789oIIphpElCpbYq2aOKbon6tzy7opQZt1GhPAiRAAm4CTEDdXLj0WQKawVZjmwpu2xrwdhzcfoAnlEP35+G+WrzJBgk7Hmxp44nqtnlp+0FXfuS0ffaxb3HTxpn2JEACo0GACehoxLlSKzUDnca2khjBRm0nKGCwcuXKbGL30P15lhfumV22bFkrZ2ythjbPWgvCOmHSBb3UMBEOfiEBEiCBWgSYgNbCN+yNNYOtxjYFtR07dhi8JxyT4beVUFkGaF9Ig8Y2BS/4tAn7okWLsnebd/298JZZiG0qXvBLDSnp0jcJkMAoEWACOkrRVrbVJiihAf/IkSNm586d2b2XIVulBLG5TQywQR80dE1v6IytOBAJDS2ztuKLplFDwgDTNQmQwEgRYAI6UuGWNxYJJc4mzp07N5jQYVC2l57bSg5sYoAWtqXBJuwSDV3Q2wUN8h55PPlbvHixwZyg9pWUGh91bS2ztvoY2o3XkOK2jbY01GXI7UmABEgABJiAsh84CdiBFitDA53G1llZhIV909A3vRFCVNtFnllbZ2ytBuwTmBsXr+Zsstj6UWdov2xSF+siARIgAS0BJqBaYiNirxnoNLap8PVNQ9/0poqbxm/bzOzMBbgyMHPmTIMzsZjBoMnSNoMm28q6SIAEhk2ACeiw41u5dfmBDpfXt2zZUjpVUN62rbMyfdOguVxfOYiBDbvALCBxYrWd4gqXnlHa6Gd5Xl3QgHfS48ExXJZnIQESIIG+EWAC2reINaQ3P9hiqqClS5dmSair+rxtW09U5zW0kZyAi0aDxtbFPMayLmiQtgNa7X3G2KaNGOd5dUVDW7ciSONGOxIgARIoI8AEtIzMiC/XDLZF2zYGxfwZRSQqmzdv7vT9eXlmbSRT+ZkL0NXb0KDZxfK82tJLDZqI0ZYESIAE/ASYgPr5jOxazWCrsU0FNK8B9+fh8iRuG2iy5DWEErp8whyyTdEGaG37jKKmXXm22K4NZvmYtaWhCxw0caMtCZAACZQRYAJaRmbEl2sG2y4Mim1rwBlFTIZ/wgknZD3Hd39efoorGCOZavqJ6rZ5aXevLuilBm3UaE8CJEAC5QSYgJazGek1msFWY5sKqiZhTqEBCSTeAT9t2rQJ92W3IhR5tfFEdVFDG2cUJ0AJvnRBLzUIAkUTEiABEhASYAIqBDVqZprBVmObguOuXbvMrFmzsldxWv9NJ1RFBtBRpkFja9sT+7OoAQ+Z7du3r7NPVBf1lrGNzSnvjxryNPidBEiABOoRYAJaj99gt5aeUTx69KjZtm1bdvbPwmg6OSgmBtDRZQ1902vj2uZnkVnT8UXbqaHNHsC6SYAEhkaACejQIhqhPbt37zaYemnevHkT3soGfFx6xn2P06cf70plthPOIn8pJgZw32UNfdMbOVyV3BWZYT7QPXv2mEOHDlXyV2Wjooam+1hx5gK0oWkNVbhxGxIgARJwETieNbjWctlIEigOtIBQNtBpbFPB7JuGvulNFTeN3+IZeWxb1ic1fjW2RQ1N149+k5+5oA0GGl60JQESIAEfASagPjojuk6TIGlsU+Hsm4a+6U0VN43ftpkVZy6AdrySE1cJ8IrOJkrbDJpoI+sgARIYHQJMQEcn1uKWlg10rqmCymyxvKnSNw1d0Fs8m4dYNX1GT9o/ilNc2e2a1OuKWdPMXBpwKwJumcGrSllIgARIoE8EmID2KVoNaXUNdHjKfOHChdkDR3kZLtumn6h2aWgyOQEPjQaNbZ51zO9d0CBtj2uKK2zbZIxdvLqgAdN+4bI89LGQAAmQQJ8IMAHtU7Qa0qoZbDW2qeS7NDSZnKBdmjOKbevFzAW4bGwnzbdxaZqZrTf06eKFbZrUSw2hKHE9CZAACegIMAHV8RoJa81gq7FNBc+lYfbs2WbBggVTztg2qaEsQdIkqyn0umYuQD1lelNo0Ph0xbdpvV3Q4Oo3TXPQxI22JEACJOAjwATUR2dE12kGW41tKpxta3DNhYq2uu7Pw9RBuGw6f/78STiaTP7a5jWp4YI/uqCXGgSBogkJkAAJKAgwAVXAGhVTzWCrsU3Fr20NmzdvNsuXL580Fyra6ro/r+wsVpNPVLfNS9sPuqCXGrRRoz0JkAAJ+AkwAfXzGcm1msFWY5sC5t69e82xY8eyB6SK/ps6q1jGAHqKGjS2xfbE+rtMA5JoTDeEp867VMr0Ftmm1EwNKenSNwmQwCgSYAI6ilEPtFk62CLx27JlS/YUbtFlU8lB2RlF6GlKQxkvlwaNbZFprL/LNLjO2Maqs46fMr1NxRfaqaFOBLktCZAACUwlwAR0KpORXrJv377sDNiiRYumcCgO+Eg+MeUSXttZLEXb4vpYf5clBvDfRQ190xsrTnX8lDHDU/w7duxo5Ixt2Q+dpvpY2cwFTfbzOjHktiRAAiRQJMAEtEhkxP8uG2iBpTjYliUGLttUWPumoW96U8VN47eMGc7YrlixwuCp/tSlbL848cQTsym4UtdfNnMB6i3ul6m10D8JkAAJxCDABDQGxQH5KBvs0cTiQKexTYWobxr6pjdV3DR+22aGNw3hLD9eu1ksY2NjBi9p2LVrV3FV1L/bZhC1MXRGAiRAAs8SYALKbjCJgG+gK57t8dkWk9VJlUT8o28a+qY3YqgqucJ9xlu3bs3OdLocNNHPfDGDprY14FYEvFgAl+lZSIAESKAvBJiA9iVSDen0DbaYKghnfHDfHYrPtqknqn0amkgMQhyKGvqmNwt0i/9hiivMp+q6zxiyinxTSPXFrAsapk+fnr3VqolbEVLwpU8SIIHRJMAEdDTjXtpqzWBbdl8cnDf1RLVPb/GMbWmja67waSgmSBrbmrKcm/tmLsAGRb1OJw0u9PFqSi81NBhwVkUCJDAyBJiAjkyoZQ3VDLYaW1nteiufhrlz5xqctcXclimLT0MxodPYptDsm7kA9RX1ptCg8en7kdOUXl/MRkmDJm60JQESIIEQASagIUIjtl4z2GpsU2FsW8P4+LjBZeKVK1c6m5i/P2///v3m8OHDxjXFFTZu4oxt27yckDwLu6CXGjwB4ioSIAESqEiACWhFcEPdTDPYamxT8WpbA84oLlmyxMycOdPZxPz9eaGzeU08UR3S0LUzoG3HF0GlBmfX5kISIAESqEWACWgtfMPbWDPYamxTkDpw4IA5ePCgWbx4can71AlViAGEWQ0a29IG1VwR0oB5Nbdt29aZJ6pDei3bmli8m1ODFw9XkgAJkEAlAkxAK2Eb7kbSwRaXnvHULRKAspI6OQidzYOuLmkIsW1Cb0gDzthiBgPcVtCFEtKbOr5gQA1d6AnUQAIkMDQCTECHFtEa7cHZRNyniEvKZcUO+JibEWceyy49Y3trW+ar7vJQYtA1DX3TWzc+MbYPMcMZW/RFPN2fqoQ0pO7noZkL0O7UGlKxpV8SIIHRJcAEdHRjP6XlmjOKoUEZzlMPin3T0De9UzpICwtCzDA/KOYJTXnGNqQhdT8PzYXaxL7WQuhZJQmQwMAJMAEdeIA1zQsNtPBlB1uNrUaDxrZvGjQJvoaDxrYLzPqkNzRzAdqycOHC7J7Zffv2aZomtu1bzMQNoyEJkMBIE2ACOtLhn9x4yUBnpwqS2NpkdXIt8f7qm4a+6Y0XqWqeQlNcWa8p+5nkRwN02P3Caor5Kek3mAYMMzKkvBUhZpvoiwRIgASYgLIPTBCQDHTz5s3LXov4zDPPZGdDJzZ2fEn9RLUkOUiZnKDJEmZWg8bWgTPKoi5okDYkNMWV9WP52r9jfkp4ob62NeBWhKVLl2ZJaMz20xcJkAAJpCLABDQV2R761Qy2Tz31VDABTf1EtURvysQAIdZo0Nim6D6SmQtQb2pm0rZJeKXWK/mRk1pDFzhIY0Y7EiABEpASGGQCystQ0vBPttMMtpIEFN5TJjOSgXnBggUGidfevXsnNzbSXxINloHGNpK8SW4kMxdgA6t30sYt/CHhlVovNbQQeFZJAiQwEgQGk4A+8sgj5tWvfnX2mkNcJj7vvPPMXXfdNRJBjNVIzWDblwQUbFLdnyc9o4j78zBnKh5S8U1xBa0pkz9NfGHbdumCXmpouxewfhIggaESGEQCije3XHrppdnl0BtuuMF84QtfyJKOK664wjz44INDjV30dmkG26effjpLlkIihpxQod/hCehZs2Z5MeD+vPnz52cTvHsNn12Z8olqTXxh23bpgl5qaLsXsH4SIIGhEhhEAnr77bebDRs2GCSfr3/967Nk9JOf/KSZM2eOufnmm4cau+jt0gy2GzdubDUBxaT5OKOIBy9CJVUSLOUFfdCJ+SolJdUZW6lenLHF3JM4w9tmkepNFV+0nRra7AGsmwRIYMgEBpGAnnvuueb66683559//kSsFi1aZE444QSzc+fOiWX84iegGWzhCYlSqKRKDqRaoa8LGpB8SpLlLujF261wqwCeQm+zSGOcKr5oOzW02QNYNwmQwJAJDCIBPfvss83b3va2SXH6+te/bp544gnzspe9bNJy/uEmcOjQIbNnzx7RWTp7Jm/27NluZ7mlqZIDaWIAKV3QgOSzLwloSma5rhH8qnkoDvfYpjhjK+1nqfqY9D7jrsQsGFQakAAJkMDPCMwcIondu3eba665xpx++unmzW9+s6iJ3/ve97JL+CFj+E752r9Q/Zr1R48ezZLw5z//+cHNMICvWrUqaAeDI0eOiOxghLOkKXhBr+QMLDSgXYivpOCM+YEDB0S3F6BdUg3f/va3gw8gWX3Qi/ZJChKkuXPnmsWLFwfN4fMFL3hB0A4GGg14IA1XG8bGxkS+pUbSPokztkjucU/u8uXLpe5FdtIYa3ghqXz00UfNaaedFtSANqFtaGOoaDTgFhYk+KecckrILdeTQGUCjz/+uFm7dm3wPnlU8Nhjj5lTTz01m2e6coXcsFcEBnEGNE98165dBg8frV+/3nz60582krN02B4Pf5xxxhnBfxgIpD7zutr4/sMf/tD8/M//vKhq3NOJe/8k5Xd+53fEZ5vWrFmTxULiV2MjvQcVPlevXm2QJEnKe9/7XvOa17xGYprddyxNQPHDRapBo/fyyy831157rUiv5OUB1pFGA/oY9rXYRdMnNXqlOvFDBPcZS5J73PKDH2aIc6hgUMYPAfxADJVUMbvzzjuzwT5UP9eTQB0C69atM9/85jdFLnAc+e53vyuypdEwCIR/VveonZjnEE/DP/nkk9kUTGeddZZYPc4E4KxpqGCwlwxIIT9NrLdn0Xbs2BE8+ya91KjVnerSpEavRsP27duzM2mSdkKD9IyixJ+1gd4HHnjA/un9hF78k5RUzHD7hlSDRCdsNJeeYa+JMewlRXoLgPVlNeDHrK/Y/VJydlUTs/ybxzDzgq/EjpevLq4bTQJ2Pm6cxQ8V3P6F0vZ95yGdXB+XwGDOgKKTX3zxxdmly3vvvTebBzQuqv55w+CFYj99LdAMdD4/xXW4NIsEWHPZvujD9bcmObCJgctPcVmqhK5Yj+/vLuiVarD3XcZOaKST5luOUr3WXvKp3SekGuz+aD99WjQaNG8eswN9qhc0+NrEdaNBwN56ZX9w+Vpt9wX76bPluuEQGEQCil9auBSJQRAPH73oRS8aToRqtMQOXpKd2trWqM656bRp0wzOzEgOQk4HJQs1enGZHAmrpOCHjDSZ0miQ1G1tpIkM7HHPqkRvqjOKSBRR2owv6tcwg72kaOMr1QC/J510UpIfhhoNOEsq3S8kvGhDAnkC6OeY/xifoQIbnKyQ2IZ8cX1/CAziEvyNN95o7r///uxJeNzblC+4ARrJ6SgW7MzSgQ4DkeRhpSoc7aCI+/RiFbQNfiUFD8dgsnjcH4x79XwFCSjO1uL+vNBlTI0GX53FdZZXcXnxbzxIgmKTwOL6/N9ol2TSfLuNVAMY4AcGPmMWLVupXo1GzVl2+JVqQNuk+2UqDnkNqfZ7DWvaDo9Avo+FWqexDfni+v4QGEQCesstt2TEMRF9sVx22WVMQAXJAQ4Ar3jFK4r4ovwtHZg1lUEv/EqL1RBKQHEmD9NM4RNPFfuKVoPPV36d9Iwt6seDY/gMFa1Wy0viFz/yJBpCvvLrq+j9zne+k3dR+3sVDRIOsNEkoJjNQ1qkcUNyLdUgrZt2JJAnoO3n7I95eqPxfRCX4HHZHZcYXf/uuOOO0Yiko5XaA4AmoXNUV7pIOiiWOnCsQNs0eiUa7FyokoQKZxQXLFiQZEaEefPmZWdfQ09UgwG0QkvoieoUvBAWTR9zhLF0USq9pRU6VqTSAL+SPgZJXdDgQMNFJBAkoO3n0n0iWDENekNgEAlob2g3LFR7ANAkdJqmSJI/jT+bKNoJ8SXbSjTYwV5jK6m7io1UA86WYu5Le8N/WV22bWXri8txWR2X9u2TrMX19m/4TXHmQqtXwstqln6m0qBh1gUNUl60I4E8AZxlP/nkk0VXRzT7RL4Ofu83ASag/Y6fV71mp9YOdN6KCytjJwdVtEo0WL8a20JTo/0p0WDvUZTY2rZJBeL+VyT4ksQW9/bi6kPMJ6q1eiUMpG23dqk0wK80aU+hwT6QJtVgefCTBDQEtP2c/VFDdxi2TECHEUdnK6T3eR0+fDibQFtzRtFZYcnC2MmBdlCGLImGlAldCZrSxRK9loPGtrRCxwqNX+l9q45qnItsLJwrHQtxLyymFgqdsXVsWrrI8i01KKyQ8MIm0oHZJorwKy0SDXaKK8QMWlhIIAUB9C28iGT//v3GPjBZVo/dJ3DvPfo9y2gQYAI60Dhj7k08/Y0HaUKDDNZjAMeUSSmKZFDU1Au9mkEZviUarF+NrUa3xlajQWPbpgZN3TYW0m1wxhavrLTzW0q389lpNUjigIEYb1fCwAz/vqKduQC+JBpsuyS2Pn1cRwI+ArafSX6c4gcnxirM1IF+zzIaBJiADjTOmp3f2qZCEXugq6JXosH61di2yUyjV3tGEe3ScJDYaljZtmm2ianBJopIaqUFMyzgagLO+JQVGwf84MPtDb6zPakYWL8xeZW1l8tHl4Cmn2lsR5fo8FrOBHR4Mc1aZHdoyRPV1jYVitgDXRW9Eg3Wr8a2TWap9Wo4SGw1rGzbNNvE1FClfmgNne2xfmfOnJm9Htd3xtbaahhoEtuYvDQaaTt8AvhhhR9Y6I+hfoYfbPjhhh9wIdvhkxutFjIBHWi884NXaKfO26bAIX2iWlp3Fb0hBqjb+pXY2jNZUs1aO4kGjV5rq9ERW4O07qpTXEn0SjVU4QXfIQ15vxpbqW5NYrt48eLs3rwDBw5I3dOOBEQE8MNqyZIlBv0x1M/zx9KQrahyGvWGABPQ3oRKJzT1QKdRI32iWuoz3zbpNpIDm/WrsZXWr7XTaNDYanSE/OIVoDjDPmfOnOAgo6nXxkGzDWxDejX+UmnI+w3pzQ/MGu0hv3kNoTO2mnppSwKWQL6PafpjyNb65+cwCDABHUYcp7Si6gFgiqNIC2IeWPJtk8rDze2YrB0PgJQV6xeXjUJPVFvbMl91l4d45WcuCNnmE0WNrpDfPIOQrabevF/Ndn3QkG9bSG/eNiaHvN+QBk29tCUBS0DTxzS21j8/h0GACegw4jilFZqdOm87xVGkBTEHuqp6Q2d7rF/JE9VVz05JcYZ4QSsSZcxcILGFjbZo/IZsNXXbOGi2gW0fNOTbFtKbt9Ww0PgN2WrqpS0JWAL5vhvqYxpb65+fwyDABHQYcZzSinyCpDkATHEUaUFIg6aa/AFLs51Pw5EjR8zOnTuztwrBp8/WTnGFS8+pSuiJ6jyD0IMneVuNXh8D+Mn7Ddlq6s371WzXBw35toX05m1jcsj7DWnQ1EtbErAENH1MY2v983MYBJiADiOOU1qh2anztlMcRVoQa6BDoogE8IQTTlAr82kAA3tGEY5DtlifuvjO2OZjFnrwJG+r0Yw2+iaG1vzI0dRbRy+2jVFSacj79fUxtCFvq2mTxm/IVlMvbUnAEsj33VAf09ha//wcBgEmoMOI45RWaHbqvO0UR5EWhA5C0mqgNZ8oSreDnU9DkYHGVqNBY6vRoLGVakBiiyel8eYcV8kzi/lEdd6vq96yZT4GZduULU+lIe83pDdvW6bTtVzjN2Tr8s9lJBAikO+7oT6msQ3Vy/X9IsAEtF/xEquVnp3CGUU8pIKpklKW0EFIWnf+YCXdxtr5NBT9amyt/9ifGg0aW41OjV/fGVtNncVYSLeFVt8ZW6kf2OX3H812Pl7wk2+bxjaWhuIDaSENmnppSwKWQL6f4xXPu3fvzub6tOvzn3nbWMeQvH9+7y4BJqDdjU1lZbt27TKzZs3KXsUJJ75BBgM2ks9Ur+G0jfBpsDaSz/zBSmKft/FpKPrV2ObriPldo0Fjq9Go8euz1dRZjIV0W/T5WK/yq6rBxyA/cwHa5LMtJopSBiG/xcTap0FTJ21JIE8gv/9gbMFVKyxzlbwt7qvHK6RxmxXL8AkwAR1gjPM7NJrnG2SKtqlw+DRo6qyj16eh6Fdjq9GvsdVo0Ni2oUFTZzEWmm19HKR+iomidDvY4dWdmOoLr/IsFrQrf/uIT2sqBkW/Pg1F/fybBKQENP1MYyutn3b9IMAEtB9xUqks7tC+J6qLtqqKFMaxBro6en0ain41tgoMKlONBo2tRoTGr89WU2fxLJ1m2xga0BfyiaKmftiWaSj2sdmzZ5sFCxYYvPmpWIq2xfW+v8vqxzZFvz5bXx1cRwJlBPAaTvQzXE63payf4YcafrDhh5stZbZ2PT+HQ4AJ6HBiOdGS4iCDFWX31rhsJxxF/IKDSoz78+ro9R3Yin41thExTXLl01BM0ny2xbZNqiTwh8+vRkOgmonVmAoLl+Hmzp07sUzzxadX6qcOL9RRpsHlV2Mr1a9JbHF/3p49e8yhQ4ek7mlHAl4C+EGFW2FwS4wtmn5eZmt98XM4BJiADieWEy1paqCbqFDwJfREtcBFZuJqm3Rb34FNk0zV0SDVCjuf3qIGn22xbTE0uBJFnwZpnXW0hphJNRTZSrezdmUcXH41tta/5FPjt8xWUg9tSKBIoG4/Z38sEh3u30xABxjbugeAVEhiHFhcbZPqXbJkidm/f3/p/XnQZwu+l52xraPB+pd8lvFyzYVaZlt8IE1Sb96mzK+LQZlt3l/ou8tvaJv8+i5rcLWtTK/LNt/O0HeN3zLbUB1cTwIuAq6+W9bHXD84y2xddXFZvwkwAe13/JzqNQcAl63TaYSFMQ4sdfVKb0XwPVHtOmhGwDPFRRkv18wFZbZ1tZb5dcWhzHZKwzwLXH495lNWdVmDKxZlelNxcPkt0zAFLheQgICApo9pbAVV06RnBJiA9ixgErmandplK6mjik2Mga6uXpeGo0ePZnOhFt+u5LLFfHZ4V/y8efOqIFBtU/ZEtYuBSysqc9lqRGj8ltlq6kultwsaXG0rY+ay1bRB47fMVlMfbUnAEnD13bI+prG1/vk5HAJMQIcTy4mWaHZql+2Eo8hfyg5C0mqQKOIG9zqT5rs04Iwiks/p0yfvDi5b11ksqf4qdi4NrpiVPXjistXocNWP7V1+y2w19bn8arbvsgZX28r0umxjcHD5LdOgqY+2JGAJaPqYxtb65+dwCEwecYfTrpFuiWandtmmgld3oNu8ebNZvnz5lERRo9eloYyBxlajQWOr0aCxlWrAE+k424uJ0fPFxSzGE9Uuv/l6Q99dDELbFNen0uDyW6a37g8djd8y2yIX/k0CEgKafq6xldRNm34RYALar3iJ1Ep36mPHjmXv+a5zRlEk6GdGdQc6V7s09cPWpaHMr8ZWq0Nqr9GgsZXWDzuNX5etpq6yWEh9lN3jK90ednU1lDFw+S2zTZGAumYuQHvLNGAdCwloCbj6Oa4w4UcsrmLli8s2xj6cr4Pfu0uACWh3Y1NJ2d69ew0SS8zDli+uQQZnFHHWCvc0NlFcGjT1ug5Wmu1h69JQ5ldjq9Uhtddo0NhK64edxq/LVlNXWSykPmK8yq+uBhcD18wFZWzLEkUpgzK/Ze1y6dXURVsSyBNw9TPc3oQkFLc75YvLFldcMCbhfnuWYRNgAjqw+JadOXENMq6dPyUOlwZNfTH0ujSU+dXYatqhsdVo0Ng2qUFTV1ksND5cHKTblz2QJt0edrhNBEkkkk5bXDMXYJ3rbE8qBmV+6/Cy7eMnCVgCmn6msbX++TkcAkxAhxPLrCVlO7Trieoy21RI6g50Zcm1Rq9LQxkHja1Gg8ZWo0FjW1dDWSxcGjR1lfnV+KijoeyBNE3906ZNy17liX5lS1kfwxufcNYWCastZbZ2veRTk9jW4SXRQpvRIlC2Dxf72eHDh7OznLgKVyxF2+J6/j0MAkxAhxHHiVb4Bq/iTu2znXAY8Uuxfq3rGHpdGsr8amy1bZHaazRobKX1w87lVzrIaOqJNcWVS69UR1lfkG5v7YoafH41ttZ/6FOT2OLS6I4dOyadsQ3553oScBFAPxobG8t+VBXXu/r5ypUrDX6wFUvRtriefw+DABPQYcRxohWaga4siZhwFvlL2RPV0mp8bZP6cB3YyvxqbKX1a+00Gly2MWJc9OtLFIu2mvaWxUHjA7Z1NMTg5dLga1tRr89Ww0LqFwkAHkQs3p+nqYu2JAACvr4r7Y/wU7TFMpbhEWACOrCYxjoApMJS58Dia5tULy73IIHC5R9byvxqLmNaX7E/i7x8MxcUbffs2ZOdXZg/f34tWUW/ZbxQSdFWU7HPr8ZPFzX42lbU67Otw8GXXBc1aOqhLQlYAr6+W+xjGlvrn5/DIsAEdFjxjPYLNBWW4kFIU4/vgCX1o7k/z/VEdQwNUq2wK/LyzVxQtI2lVeO3aKtpayq9XdDga1uRmc9W0xaN36Ktph7akoAl4Ou7xT6msbX++TksAkxAhxVPJqCCeOYPhDijuGXLluyhEdemedt9+/Zl89gVp7hybRdrWfGJat9Bu3jG1mer0ZdngO18fou2mnp8fjV+uqjB17aiXp9tHQ4+v0UNmnpoSwKWgOYsO/ujpTa6n0xABxZ7zU7ts02FpepAF0oUNXrzGpB8YoaAsrlQ87a+g6umfo1t8YytT0PxwZNY8dUktnlemnbCNpbeLmrwta2o12erYarxW7TV1ENbErAEfH232Mc0ttY/P4dFgAnosOLpHcQ1B4BUWIoapPWEEkWpH9jlNfgSuqKt74CpqV9rm9cb0qCxlerAU62zZs0yu3btyjbxaajzRHUoFlK9eQbSbaydr23WRvJZ1ODzq7GV1G1tin59fIu21gc/SUBDIFY/Z3/UUO+vLRPQ/sbOqVx6ABgfHze4nxDTYDRZqh5YfO3S6s9rCPnV2Gp1SO01GjS20vphJ/Vb54nqUCykeotnbKXbwS6WhjyvkN+irS9R1LQl79c3cwF85m01ddCWBPIEfPsPxhqcSMDVLBRfP2d/zFMd7ncmoAOK7YEDB8zBgwfN4sWLna3K79Q4ECxZssTMnDnTaZtqYV6Dpg7fgU3jB7Z5DSG/GlutDqm9RkPe1neAl9Zt7fJ+Nczs9pLPkF+JD9jUeZVfLA15Xni70tatW0t/7OVtY81cAA55v6F25W2xLQsJVCHg62e4zQm3O2HsQfHZLlq0KJupZP/+/VVkcJueEGAC2pNASWSGEo78IOPb+SV1VbXJa9D4iKk3ryHkV2OraY/GVqNBY9uEBk0doVhofOU5SLfzTXEl9WHtMK/mtm3bsofWcKUBD5PhfdiukteaikHIb16DSyOXkYCEgKafhWzrXMmQaKVN+wTcR8T2dVFBBQKhHTr/RHXItkL1ok2qDnQx9eY1hPzmbUMJvghABaO8Bo3ekK1GSlUNmjpS6ZVq8E1xJfVh7ZBsYn+Dz1C7FixYYHBLzN69e4O21r/ks4mYSXTQZnQIhI6Rtk8eOXIke/sW7hkvK9a2bD2X958AE9D+x3CiBaGBLv9Edch2wmnkL1V/1cbUmz+whfxqbCOjmnCn0aCxnahA8EXjN28rcJ2ZxJ7iqoqGUF+QtsXaWQ0Sv3a/CA3g1rfkU5PY4owtbhOw9+dJ/NOGBPIE8JAiHlbEQ4tlxe4TeOsW+hzGpLJibcvWc3n/CTAB7X8MJ1ogGejsTi2xnXAc8UvxiWqp65h6LQPUHfKrsZW2RWun0aCx1eiwfnFPFt4ihXu0yoq1LVvvWh4z8YL/KhpCfcGl27fMapD41dj66iyus4ltSAPuz8NbwnDGloUEqhAI9TH41PRza1tFC7fpBwEmoP2Ik0hl7AOAqNIKRlUOLJK2SaXgss/27duz+/NCfu0ADt8hW2n9WjvLSzJzgbWVJIoaHdavJFG0thr/sdl2SYOkbVavxFbDVePX2mr805YELAFJ37V9TGNr/fNzeASYgA4opprkQHIASIXGHoQ0/mPqxf15SEJxGSjkN/9EdchW0x6NreUlmbnA2kr6QhUNEgZWg8a/xK/GX5c0SNpm9Upsq3CQ+LUaNP5pSwKWgKaPaWytf34OjwAT0AHFVLNTS2xToaky0KVKqJCEQo+vYP3GjRu9U1z5tq+7zj5RDQYSrYht7PjamEniYG017U6ltwsaJG2zzCS2mjZp/FpbjX/akoAlIOm7to9pbK1/fg6PABPQAcVUs1NLbFOhsQchqX9cepYkilJ/sIOGp59+OpszNTQXKmyfeuopg8vxbRT7RDX0Qouv2AdPnnnmmaCtz09xnY2ZpN9Y26IP398Sv77ti+u6pEHSNqtXYltsq+9vjV9r6/PHdSRQRkDSd20f09iW1cfl/SfABLT/MZxogWanlpzJmnAc+Ys9CEnd4ulcTK4fShSl/mAHDUgq8RkqGtuQr6rrNRqQKEvbJtWzcOHC7J5ZSWJb5YlqSd+VaoUdeMGnpsTeJ6wGSds0tpo2afxaW41/2pKAJRC7n7M/WrLD/WQCOqDYag4Asc8oajBqDyySdmnqhy00SJM0ja1Wh9Reo0FjK60fdtLEtsoT1bFjDAbwqSmpNEj8Wr0SW02b4Bc/GjDvom/mAvi0GjT+aUsCloCk76KPSe69h0/2R0t2uJ+DTEDx6rtDhw4NN2qOluEVnJhLEa868xXs1LiUizNamLOtjaI9sEgObNp2WA74DBWNbchX1fUaDRpbjR6NX9gibtISO8ZVXuUXW4NlgKmN8B5sX4Et7jMOTXHl8+FaB7/S20esXpcfLiOBEAHJ/oMxB2OP5HYijGUY0zC2sQyTwOASUEykfOWVV5q3vvWtw4xYSaskOz82tQMSPtsq2oFO2jZNezQcNLYaDRpbjQaNbUoNiJu0pIhxfgqtkA7JFFchH8X1SDpxWX/JkiXB20dszGLfZwy/ksEe2mGriVmxvfx7tAlIb2GxfR2focI+GSLU7/WDSkDxS+maa64xX/rSl/odlQrqpQM47s/Dr8rQGZkKEsSbaA8q0raJBTxrqD0ISi/XazRobKF3/fr1ogehNG3TapBy6EqMpQmVZIorDSvY4p7luXPnZhO8h7bFPc44+4n9M2ZBHKS322hjFlMnffWfgDQBxdiD185K+jr7ZP/7ha8FM30r+7TugQceML/7u7+b3e/UZnLVFjNpkoYnqlHw1pO2ivagIm2bpj3QoLk0KU28NBo0tlYvPkNFYxvylV8Pvxg4pBqkyd+BAwcM/uFMYcwCnVINKfoY2oLLiKHbYmybMees1NZuE/pEYosiHeyRrOJssO8ViaE6uX70COzZsyfrM/Pnzw823o49uFc8VDT7cMgX13ePwGDOgN54441mzZo15qGHHjLr1q3rHunEijQDqGZQTCHbPlGNM7GSommbxB9scGDDfcLSZGrnzp0iW2n9WjvoRJIm1WvbqK3HZ2+TGEmiCJ3S5E965sSnzbVOoyFFH4Mmzb6msXW117dMktjijC0SVsw6wUICGgKa/UfTzzX7sEYvbbtBYDBnQK+99lrRr/xuYI+vItUBIL7S5zza+/MkPxY0bZPqtWfJ7advO5v02U+fbap1tm776avHJoqSpMPnp7hO4w86H3nkkaIL598p4ouKoAG+JSWVBjCzZ3xCOmCnYRzyZ9fjB4PUr2WGN4WxkICUgGb/QV/U9kepDtr1i8BgzoDaQbcq/nvuucecccYZwX84O/Dkk09WrSbZdrh0tmrVKpF/XCaxl+ZEGyQwWr16dfaAhsQ1niKWtk3iDzb28o9koLXT18TWINUKO6tTMnPB8uXLNa7FttJECg4RX2nyp+m7YrEd0YCz/bb/hLSn2i9xaV9y1hr6NPtlqD1V1+M+fpwVl5Tf//3fNzt27JCYim1wC8Jv//ZvZ7ciiDcaoOHDDz9scGJHUjT7MMYeyaV61Ks5jtx+++3mlltukcg1n/nMZ8y//uu/imy7YPTBD37Q3H///V2QElXDYM6A1qVy/vnnm89//vNBN6985SuznSJo2LAB5vp7+ctfLqr1O9/5jsgupRGSuQ0bNoiqQNskZypFznJGGGikRWMr9amxO+mkk8QD4kte8hKxrUbDFVdcIfaL+OLpa0nB9EMp4gsNd955p0RCNgVSCg1f/vKXRfXD6L777hPbagyl+xl8avZLjQaN7Uc/+tEsAQzNCIAZT2666Sbzjne8w5x99tmaKry2SKY++9nPmuuuu050y4vXWY9XfvOb3zTvf//7zV/+5V8GW6HZh+FP4hOVoj/i5JCkIGYYK/AsSKjceuut2UkI/NDoQ0ECivuyL7jggj7IFWtkAvozVPhFdvrppwfB4cyZ5CxU0FFkA80lkMhVV3JnL/WFNkbih7aFBqOQH65vloA0vlCVqu9qNUj2/2YpNl+bhlkKdfa+cMl9qJi5AAUJY8xiz9yn6pcxtab0tW3btmxmBkkdqVhp+uP27dsN/kkK7OwDuRL7tm00bWtbq6b+wVyC1zR6iLapDgCpWEkPLDgItjlpfqr2D90vbhnAQRMvhQiVVH1X2segL9WDUKG2d229hlkK7fbSO/pEqMAGSYTENuQrvx7+0H9j+83X0YfvOPai4ExzqIAV+k7soumPON5YzSEdfUzooHlohQnoQCKa6gCQCo/0wNK3dqXi1Te/SAwwiEvOTqWKsbSPgW0qDX2Lm4ZZirbZOOAzVGCDW1MktiFf+fWp/Obr6MN3u+/aM80+zWCGvhO7aPojkk9pkoYz7FLb2G3S+tu9e3e2iSQOWt9t2zMBbTsCEerHdEKYh03zkEiEamu5kB5YUh3YaonnxiICbcd4wYIF2T2rmLs0VNjPniMkjVmIZ9X1iMPatWtFSaXGVqMnlV+Nhi7YggPuwcRnqMAGfSd2wQNLeMEMpqALFSSUGAcl9+trktVQvanXgy3GdkkcUmuJ7Z8JaGyiLfhLtfOnbIp0oOtj21Jy65PvLsTYTvfl44YBC2d7Ugygvnq7uE4as1Tasb9Lz2ricv3JJ58cfWDWaEjFoQt+NRxS3sIi2YdxmwCSSiRqoTOFSFLxHMeRI0dEiW3bsdDEoW2t2voHmYDiadJ/+qd/0rLorT06aN8GT+lA18e29bYjRRbehRhLNOByHM60YCL2US8SXikZaQZbja1Gcyq/Gg1dsNVwgC36Tooi6ZOYqg/JJ5JVaPEVq1WS2Pr8NLVOE4emNMWqZ5AJaCw4ffFjd6i+6IVO6c7fx7b1KQ4ptUoGDlxew5PP0omptXolGtjHjlPFVFQ4gyR58OT4VvG+aQZbja1GYSq/Gg1t2yL+6AeS2yGw/+JhQzwsmqJo9uHYtinao/WJ/oi3PO7fvz+7HUG7fZftmYB2OTpCbeig2PH6VDA5Nqa0sjdYl2nvY9vK2jJqyyWDQcpLd+At0cA+drxnYp/Ej4HQZczjW8T9hlhIkh7UqrHVqEzlV6OhbVvEH/1AckaxS/uwZn+X2LYdB9Rvj0/SkzZd0CzVwARUSqrDdraDdliiU5rkANDXtjkbPGILuxDfLmjoW9glzFK1Cfs7zvYcPnw4O+Pjqwe2uF8Ul18lD574fOXXWb/4HNWCtqMfSPqCtU3FSqMhtm2qNmn8Wr6Stmn8dsGWCWgXolBTg+2gNd00vrlkh+pr2xqH2cEKuxDfLmjoYGi8kiTMvA5qrLT7u+RsD2xhh9eMxjpjax9IQ2KLB9NiJrY1sDS+qY2DpC9Y21QiNRpi26Zqk8av5Stpm8ZvF2yZgHYhCjU12A5a003jm0t2qL62rXGYHaywC/HtgoYOhsYrScLM66DGSru/hzTYRBF2IVuNHPtAGp6SxoNpkjcyafz3xVYaB7TH2qZqmyS+VkNs21Rt0vjVtE3jtwu2TEC7EIWaGmwHremm8c0lB4vU9xc13ugRqlAS39R9twsa+hZyCbMUbcIDaXjQAmc0QxpsooiZC0K2Gq35401MvxoNXbC1+6WEgbVNpVujIbZtqjZp/Fq+krZp/HbBlgloF6JQU4PtoDXdNL55aIfasWOHGRsbM3PmzGlcGyusT0DyRHXqvhvqY2hlag31STbrQcIshSJN8pePWUy9qfym4JXSp+UAtqFbEaxtKj2S+FoNsW1TtUnjV9M2jd8u2DIB7UIUamqwHbSmm8Y3Dx0s+tquxkF2tELJE9WpYxzqY0CXWkNHw1MqS8KsdOMaK/JxCGnQ2GokpfKr0dAFW8sBtyJgeiXfO9atbSrdob6Aeq2G2Lap2iT1iysCeCBv0aJFUc/0S+tPbccENDXhxP7xNgecKcR7t/tWQgcLe1DpW7uo9ziBtmMseZUf+9nxeOFbKGaTreP9lY9DSIPGVqMwlV+Nhi7YajjkbVNoxwTzeHsRXjldVuzZ81C/wfZWr8S2rL6mltt2ob4+6NVyYQKqJdYxe+xMuNQ5bdq0jikLywntUPZAEfZEi64S6EKMQ09Us59N7j2hmE22jvdXPg4hDRpbjcJUfjUaumCr4ZC3TaXd1x/wQBqm4sI4OHv2bLNgwYLSM7Z4pzzuNcYPU0lim6o9Ur95tj4GUn9ds2MC2rWIKPXkO6hy09bNQztU/tdf62IpoBKBUIyb6L8+Ddu3bzd4KQLvMz4eXh+v41bxv+X7QkiDxlajNJVfjYYu2OaPvZpYpNLu04ApuPDgmn2Vrs823y5o9dmmaovGb15v17Vq2mVtmYBaEj39zB8w+9aE0A7V57b1LRap9PpijHub8CYsnIlIWXwa8gf4lBr65Bu8Qg+epGhPPha+mKHu/LEhZKvRmsqvRkPbtvkprqDFxzc/c0FK3T4N+ZiF9GpsU7ZH6juvF8dJHC9x3BxKYQLa80jmO2jfmoIbq31vPOlz2/oWi1R6QwNHE7ePhDRgPctxApIHT45bx/uW3999MUONGluNwlR+NRrats1PcQUtvljkfzSk1O3TkI+ZVq/Pb8r2SH3n24bb7HC8xLKhFCagPY9kvoP2sSm++/P63rY+xiO2Zt8Bvqn4dkFDbK6p/fmYpao73x/wHvJ9+/Zl9+u56svbxtSayq+rDV1dlmcAjT6+RdtUbdJoiGWbqi0av0W+vrZp/HbFlgloVyJRUUexg1Z009pmvh2q721rDWqHKu5CfLugoUMhEUnxMRM5qGBU3N99GvJn3kIPnmik5DX46tf47JttngG0+zjk45CynT4NGr0a25Ttkfrum15pu6wdE1BLoqefxQ7at2ZoDix9axv1+gevpvou+5i+J/qY6b3Jtij2B58Gja2sdpM9OY0nqJHQouDBNDyghgfVRqlo2BZtU3GK1ReKen1+U7VF47dvejVtgy0TUC2xjtkXO2jH5AXl+A4ATf26DoqkQWUCXYivT0Pf95/KgQls6GMW2LTSaszxiLke8w+klWnApOj5RBEVltlqxLj6Qgy/Gg1dsC1y8DEo2qbSr9EQyzZVWzR+i3x9bdP47YotE9CuRKKijmIHreimtc3Kdqhdu3YZPAyBV3Gy9JcA4lv2RHVTfbesj4FqUxr6FkEfsxRtccWhTIPGVqM1lV+Nhi7YFjl04T79sr4AXkW9sWy7GAtf27qgV6uBCaiWWMfsiztfx+QF5ZTtUH1vV7DhI2Lge6K6qRiX9TGEoCkNfQu3j1mKtrjiUKZBY6vRmsqvRkMXbIsccCsCTgTgjXvFUrQtro/1d1lfgP+ihli2sbRX9eOa4srXtqr1tLkdE9A26des++jRo9l9SytWrKjpqb3Ny3ao4kGlPYWsuS6BtmPse+MJ+5k7umUxc1vXX+qKQ5kGja1GWSq/Gg1dsNVwcNmmaANeNY0EGK+eLpaiBs0Z27I+Vqyjjb9dt6B1WW8VRkxAq1DryDZ4/djy5cvN9On9DWPZDlU8qHQEOWVUINCFGJdpcB3kKzRxcJuU8UrVUNf+XqZBY6vRm8qvRkMXbDUcXLYp2oA5MHGiBbfzFEtRw9y5c7MHyHbu3DnJFGcUMbUXpviyxZfYWpu2Povtgo6yfaItjXXr7W/mUrflA9je1UH71qyyHWoIbetbLFLp7UKMXRowQOHyIgYslskEXLwmW8T9y7W/l2nQ2GpUun6MlGnQ+O2brYavyzZVe12xcD2Qhvpdti6tvsQ2VTukfl16Xe2S+uuiHRPQLkZFqMnVQYWbdsasbIcaQts6A7llIa4Y41IaLqnhDEQTxaWBfaycvO8yZvlW1de4YuGKGWrQ2GoUpfKr0dAFWykH18wFKfW7+oNLKzTUtU3ZDqlvV9twvMS0YLj9bgiFCWiPo+jqoH1rTtkbT4bQtr7FIpVe12CAS2m4pIYzEE0Ulwb2sXLyvgdPyreqvsYVC1fMUIPGVqMolV+NhrZtkdxg7lPEP19csXDxym8T+7tGQ13b2Nqr+HPxxe12SEJdtyJUqaPtbZiAth2BGvW7LhnVcNfappqDRWsiWXFlAl2Ibxc0VAbY0oYuZqmkuAZb3N+O2ySKD564bGOcsXX5bZJBKrYavy4G2N7FocxWU5/G1qWhbAx02ZbpddlqdKWy7ZveKhyYgFah1pFtyjpoR+SJZbgOAENpmxjCgA27EN8uaOhbiF3MUrXBtb/j7PjKlSuzM575el22ZQ+e5LcLfXclMzES21C9XVrvYgt9rr5QZpuqPRoNdW1TtUHjt4yvq20av12yZQLapWgotZR1UKWb1s1dO5RrMGhdKAVUIuCKb9N9twsaKsFrcSMXs1RyyvqDS0PZscFlK9WL+5Ex12Xx0jOWYS5bvBhjFIqGbVnMUnFyxbdMQ13bVG3Q+NXEQuO3S7ZMQLsUDaWWsp1P6aZ1c9fBomzna10sBagJuOLbdN91aWAf84fSxcy/RbW1vgfSihp8MxcUbTVqfP2xYJXmlwAAQABJREFUjl+Nhi7YlnFwMSizTdUOjYa6tqnaoPFbxtfVNo3fLtkyAe1SNJRayjqo0k3r5sUdCu+ExuW3+fPnt66NAuoTcF3GbLrvFvsYWtW0hvokm/XgYpZCAeKAS+2uB9KKGnwxK9pqtKbyq9HQBdsyDn3bh119oewHp8u2y7Hoqt4qzJiAVqHWkW3KDhYdkSeWUdyhhtIuMYCBG7qeqG46xsU+BuRNa+hbmF3MUrTBF4eiBo2tRmsqvxoNXbAt44An42fMmGF27949IbPMdsIg8pdiX4D7Mg11bSNLV7vzTXHlapu6go5swAS0I4HQyjh27JjZsmVLduZAu23X7Is7VNlBpWu6qUdOoO0Yu954wn7mj18xZn7r6mt9cShqKDuLhdqLthpFGg0av32z1XDwxSJFuzFt29atWw3GPlvK9Lr6gsbW+m/rs0wr9Lja1pbOuvUyAa1LsKXtkXxiDk38Ku17Ke5Qvp2v720dVf1txxiXd4uv8mt6AO1b7IsxS6Xft78XNWhsNXpT+dVo6IKthoPPNkVbMNYtW7bM4BXUtpTtwwsWLDDj4+Nm7969menhw4ezs7fYvlhciW3Rpum/fWyL+0TT2mLWxwQ0Js0Gffk6aIMyolRV3KGG1LYogAbgpBjjsoEjZVPzGnApEQMaLi2yuAnkebkt4iz17e9FDRpbjbpUfjUaumCr4eCzTdWWfH8om7nA1p2/bxVay+4zdiW21kdbnz62eQZt6YtVLxPQWCQb9uProA1LqV1dcYcaUttqwxmIg3yM8Ro5vMMZZx6aLHkN7GNh8vkBPGxd3cIXi3zMUIPGVqMolV+Nhi7Y+n4Y5mOBmQswIwFeFtBkyWvwxQyaqto22Z6yunxtQyKNK6D5WxHK/HR9ORPQrkeoRJ+vg5Zs0tnFxTeeDKltnYXesLD8YIBLaIg5XivXZMlrYB8Lk3c9eBLeSm/hi0U+ZvCssdUoSeVXo6FtW98UV9CWjwV4lZ1RTNmOogb8XVaq2pb5a3K5rz/ijC1uv0MS2vfS7AjQd1od0u/roB2SKZJSfOPJkNomAjACRprBIBWOLmhI1bZUfvPMUtXh299xlhxny3HWHMVnW0drKr+pmKXw62OA+vJ8Q7Yp9Gk1aPTmbVNp1/gN8e2aXk3b8rZMQPM0evQ91EF71JRMan6HGlrb+haLFHq7EN8uaEjBNqXPPLNU9fj2d5wlx9ly++CJz7b44IlGr/TSs8Zn32x9bNGWfF8I2aZqu0ZDVdtU2jV+Q3zzbdP47ZotE9CuRUSoJ9RBhW46Y5bfoYbWts5AblFIF+LbBQ0thqBS1XlmlRwINgrt73kNvkQRVVW5bxWv2Zw5c2bpA2kLFy7MzsDu27dP0Jr+mmjiELJNRSHfF0Iaqtqm0q7xq2mbxm/XbJmAdi0iQj2hDip00xkzzcGiM6IpREygC/HtggYxsI4Y5pmlkCR5IM1qkMxcYG01WiXH0iqJrUZDF2xDHPJsQ7ap2qPRUNU2lXaN3xDffNs0frtmywS0axER6gl1UKGbzpjZHerAgQPm4MGDZvHixZ3RRiH1CeQH8Lb6ru1jaE1bGuqTbNZDnlmKmiUPpFkNkphZW43WVH41GrpgG+KQZxuyTdUejYaqtqm0a/yG+ObbpvHbNVsmoF2LiFBP6FKU0E1nzOwONbR2dQZwy0LyT1SHDq6ppNo+Bv9taUjVtlR+88xS1CGJg9WgsdVoTeVXo6ELtiEOixYtMpjQff/+/a3tP7YvgFdorMjbhtqWt207FpjiCnOc4u1tZaVLess0SpYzAZVQ6pgN3vCwadOm7KbwjkmrLMfuUKEDReUKuGHrBNqOcf6NJ+xnsu5gYyaz1ltJ4mA1aGw1SlL51Wjogq2Eg72SIbFN0Sb0BYx9GANDGmy/gQ6NbQrdGp9oH45VmB2mrOTbVmbTh+VMQPsQpYJGvA8Xl6hx4/xQit2hQr9qh9LeUWyHjXFoMEjFJv/Gk7Y0pGpbKr82Zqn8S+JgNWhsNXpT+dVo6IKt5NiriUWKNmHMw9iHMTCkF3a4nQtnbLdv3x48o2gT2xS6NT5D7YIvGweN3y7aMgHtYlQCmiQHzICLzq22O9QQ29Y52C0J6kKMoeGZZ54xuMyFS4osfgI2Zn6r6ms1g63k2FBFbyq/1am0s6WGg8Q2VSsQ4w0bNphZs2aZsbExbzU4Y/vUU09lyafvxRf5xNbrsIGVErZV+nkD0tVVMAFVI2t/A0kHbV+lToHdoYbYNh2J4VrbGOPBE7xFpY0CDRiQMDCxhAnYmIUtq1lI9nerQWOrUZPKr0ZDF2ylPwZg18ardC0j9Ienn35adAuaZn+3/czW09antD925YxtHU5MQOvQa2lbSQdtSVrlau0bT3Bww4GAZXgE7MCxZMmS1m4fsRrYx2T9K//giWwLnZXkWIZYwU5jq1GRyq9GQ9u2kimuoNHuP228Stcyggb8iJTsw1pb9IW2i6Q/4uwv5qfFD4E+FyagPYyepIP2rVn2jSfSX7Z9ax/1Pjd4SQeOVLw0A1IqDX3zax88SaFbcizD2XKcNZeeodMmERIN6Ddavyl4pfIpYYC67f7T5hUEqwGfoaK17UKMNbHogt5QDHzrB5mA4gm5IRdpB+0bA83Bom9to97jg5dk4EjFi31MTxbMUg10kmMZ7s/DWXPJj1P74AnmE5YWiYaUDKQ6U9pJGKD+Luw/Gg1a21T9XBM7TSy6oFfTtqLtYBLQPXv2mHe9613mtNNOM8uWLTO//uu/nj0pV2zwEP6WdtC+tVVzsOhb26j3+ODVl7MnjNlzBLBfphropMcyzbFBc8YWr9fE25hwOdNXkADjaWo8VT3EkiIOqTihL0h+jKB+rW2qfq5hoYlFF/Rq2la0HUwC+u53v9vcdttt5vrrrzf/9m//Zn7yk5+Yiy++OJsvrNjovv8t7aB9aycOFlu2bBHd29O3tlHv8QQUcW6raAaktjR2rV4wSzHQHTt2LNvfJQ+k2Um5Q4ki2Gn0Si7r23hoElu7TV8+pWNKF/YfaJDeyqO1TdHPtX1AE4su6NW2L2/vTUCvuuqqLJnD2w+6XL773e+af/zHfzQf/vCHs6TzF37hF8ynPvUp8z//8z/mzjvv7LL0StqkHbSS8xY3woNIKEuXLm1RBatORQCDwaFDh1r9gaEZkFJx6JtfMEsx0OHHJvZ1zM8aKrALTbljfWj0ao6lGr9WS18+pRzAAGeC8dlWQd1MQHU/tNqKVahebwK6d+9e8xu/8RtmzZo15o//+I+zhC7ksI31d911l5k9e7a5/PLLJ6o/44wzzAte8ALzH//xHxPLhvJFerDoW3uZePYtYjq9dt5N+0NDt3Ucawxe+EHd5gAapyXNeQGrFAmo5jiG26rwT1I0ejUaNH4lOrtkI+Vgj9Ft78O4FUKyD8Nm586dYtsU/VwTZ9wOIp3iagj90ZuAfuELX8jutcC9lV/96lfNOeecY84++2zz93//99nrsDRgU9o++uij2aurkITmy+rVq8UHTnTojRs3Bv/hshE6SZtFerBoU2OVujHA4J3hLMMmYAexNlppBy372YaGvtWZaqDTHMfQZ6T9RqNXo0Hjt28x1nBA26SxSMHB7rv201eHtbGfIVtwaLNgtgfpFFdoU9t667LyJqBwjvte/vRP/9Q8/PDD2b9f+7VfMzfccEN2VvQ1r3mN+fd///fW77PctWuX89cxdhJpgP7rv/7LvPSlLw3+w6+T9evX1+U+Zfu3v/3tBsltqOCVYrgPas6cOSHT3q0/99xzzZvf/Obe6aZgOYE3vvGN5vTTT5dvENkST1T/0i/9ksGPUxYZAVwBw72SsQsm0l61apXI7UUXXWRe+9rXimzXrl0r1ovxQdoXwAEnKSQFVw7f+973SkzNJZdcYj70oQ+JbC+44IJs/BUZK4w0sXjDG95gXvjCFyq8xzXF2PeLv/iLor6DkxoXXnhhdoIqpALxbXtyd9Sv6Y8p9ssQp5jrxS8Tx0S1Dz74oHnooYfMk08+mQUUCdNv/uZvmvPPP998/vOf975rNabooi9Myup6zda0adOye86K9q6/8cASXtEXKvjV8bznPS9kpl6PB6fwIBUOnr6CA6Dkpn2fj66ue8UrXmHwj2W4BG655ZbWG3f33Xe3rqFPAnASAq8+jF00xzKc7MA/ScExWnrvPzSceeaZErfZyRg8byApOEmxYMECiWk2nuKpbknB2Nt2LG699VaJ1KQ299xzj9j/f//3f4tscS8ybhNq801tyEGk43uq/VIEK5KR9wwo7pXCGc7Xve512T0Uf/AHf2Dmzp2bPW2Om4Bxif7xxx83jz32mPm7v/u7SJL0bhAInBksFiyz950V13Xtb+npdPxihy0LCZAACTRBQHps0mrRPIGu8a3RqzmeavziSplrTHK1I5Wtq66yZUjEpWejy3wMYbkmxinaq+mP9gUNfZ733JuA4kwfLrn/6Ec/Mn/zN3+TnSH83Oc+Z6644oqJJxfRaXFfKMC1VaABv1qK92biALdu3bq2ZKnqlXZ8TQdVCaAxCZAACTgI4EweBjk8lBqzpDqWSY+laItGg8avJqlEoipNVo8cOSK2lcYKc2jjauH8+fOlmwzWThPjFBA0/dG+oAGzSfS1eBNQ3OuBS+7490d/9EfZzbGuht58883m4x//uGtVI8t+5Vd+JTs45k/LYx7QH/zgB+aXf/mXG9FQtxJpx9d00LqauD0JkAAJgACuMsW+3yzVsUx6LEW7NBo0fnfs2CFKFHEbG/4hYQ0VTJqPEjvh0DAIaez7ek2MU7RVG4u29dZl4E1AP/jBD2ZnN0OVAALuw2yrvPjFL84eLMBUUf/7v/+b3SPzlre8xbzyla/MppFqS5emXmlH0nZQjQbakgAJkICLgPT45Nq2bFmqYxke0sTVMJuwldWP5RoNUgaoF88kSBJF2ODMIx4+CRX8AMCE/NAcs2gYxKy3i76kMU6lXRuLtvXW5eBNQOs6b3L7T3ziE9n9nng679RTT81uEcBZWVxa6EORdiRtB+1D26mRBEig2wSkxydNK1IeyyRnbDGhOp5zkD4nADvYYztfQaJ40kknZQloaGYTMMCDp/gMFY1tyFd+fco45Ovpw/cU/VzTbm0s2taraZvLdjAJKKZQ+MY3vpHdC4og4ilITEbflyLtSNoO2pf2UycJkEB3CUiPT9IW4J7SlE8bS/QiUUSiqimSxBbHaNhhGsDQWVBoQAIqSWzhF4ktuMV88IRjyvEeIOk3x63jf9PGom29dQkMJgG1IHCJQvrGDLtNFz6lHUnbQbvQNmogARLoNwHp8UnaSiRmS5YsMXiQIkWR6K1yLNX41dhqEltwCyW2GqZVOGj898lWErOU7dHGom29dVkMLgGtC6St7aUdSdtB22oP6yUBEhgOAenxSdri1Mcxid4qGjR+27SVxgF2VTho/PfJVhKzVO3B7Rpbt24VTZpvNbSp12qo88kEtA69iNtKO1KVy0YRZdIVCZDACBKQHp+kaFInPRK9VTRo/Ma2tcd+iV9pHGBXhYPGf59sY7PVtB23VuDqLSbEl5Y29Uo1+uyYgProNLgOtw5gLrjiXKZ5CZjaY2xsbJCv4cy3k99JgAS6RSD2QJc66ZHoraJB47dNW03vqcJB479PtohZW6/jrBIHSR/rMn8moB2JDqbtQBLqm46jSgftSPMogwRIoMcEYg90qY9lEr32jKImLBK/tm1t2mraZPVqthmqLaaTxDReknlZYzOoEgdJH4utM6Y/JqAxadb0FepMVTpoTUncnARIgASy1//i+BOrpD6WhY6laEcVDRq/bdpq4lSFg8Z/32wlcUvRpipxaEtrrPYzAY1FMoKfUGeq0kEjyKILEiCBESewePFic/DgQXPgwIEoJFIfy0LHUjSiigaN3zZtpUFCPBFXxJflOQKSuKVgVaU/zp492+BVuW2csY3BgAloDIqRfIQ6fpVLRpGk0Q0JkMCIE5BMFSRFVGWwlfqGXehYCpsqGjR+Q7aYyxO3XMEuZJtPFEO2aJu0cEyZSiom36ney5dU6Y/w1pbe8pbI1zABlbNKbhnqSFU7aHLhrIAESGDwBELHJw2A1McyzJWJNxbh7F5ZqaIhxAD1oV7UH7LFlDs484i5UEO2+UQxZFvWXtfyKgxcfoa0LCZfDZeqsWhLr6ZtZbZMQMvItLA81JGqdtAWmsIqSYAEBkYgdHzSNLeJY5nvjG0+UdToxtuN8K73ssS2mCj6nqjOMwix1dhq2pP3q9luyLahWKRqe77vaOpoS69GY5ktE9AyMi0sD3UkHixaCAqrJAESyAiEjk9STLj0jGMZEsSUxae36mAPvT6/+WN06InqvG0osc3b+urX8qzDQVtXX+xj8tW0OR9jzXZt6dVoLLNlAlpGpoXloY5UtYO20BRWSQIkMDACoeOTtLl4YAJT3SBBS1l8euscS31+iwmdz7aoQWob88GTooaU8eiLb18cUrahaiza0huDBRPQGBQj+Qh1pKodNJI8uiEBEhhhAqHjkxRNU8cxn946GjR+27CVxgF2dTho6umTrS9mqdqBqwJ4E9LKlSvVVbShVy2yZAMmoCVg2lgc6kjFX9dtaGSdJEACo0kgdHySUmkq6fHpraNB47cNW2kcYFeHg6aePtn6YpaqHVu2bMkeXMMDadrShl6txjJ7JqBlZFpYjl8/6IjHjh2bUvuuXbuyS1Z4FScLCZAACTRNINZA11TS49NbR4PGbxu2mn5Rh4Omnj7Z+h5eS9WOOnHw9bFUemP5ZQIai2QEPzNmzDC4GR1JaLHU6aBFX/ybBEiABLQEYg10TR3LfHrraND49dkWr2j5bIt6fbaauBb9arYdqu2cOXMMTvTs2LGjsSbWiUOsvtBYY3MVMQHNwejC17LOVKeDdqFd1EACJNBvAmXHJm2rmjqW+fTW0aDx24atJh51OGjq6ZutL24p2lInDm2csY3FgAloLJKR/JR1/DodNJI0uiEBEhhhAsuWLTN79uwxhw4dqkWhqWNZ2bEU4uto0Phtw1YaHMxlijlNcdWNZTIBX9wmW8b5q05/nDt3rsFZ2507d8YR06AXJqANwpZUVdbx63RQSb20IQESIIEQgbLjU2i7/PqmjmU+rXU0aPzGsEWiuHfvXoMfALb4/Fqb0GcdBiHffV8fg6+GQd1YNK1X0zafLRNQH50W1pV1pLodtIWmsEoSIIGBESg7Pmma2dSxDAnb7t27zeHDh6fIq6OhjAHODOMMsSRRxFyoCxYsMJjT05Yyvy6tZbbWl+TT5Vey3SjYxOCr4VQ3Fk3r1bTNZ8sE1EenhXVlHaluB22hKaySBEhgYATKjk+aZjZ1LJs2bVo2ryLqyxckikhMly9fnl8s/o7tcLnzyJEjk7Zxtavs/jyXbRlbje0kQYE/XH4Dm4zM6rJYpAJQNxZN643FgQloLJKR/JR1pLodNJI8uiEBEhhhAmXHJw2S4tPfmm21ti69dY+lZYmty2/ZE9Uu2xiJrYaPS4Nm+yHbuvpNyvbWjUXTemOxYAIai2QkP2UdqW4HjSSPbkiABEaYQNnxSYoEU9tgihskZk0Ul94Yx1KNX6mtJrGN8eBJDA5NxLCNOlwxS6mjbiya1huLBRPQWCQj+SnrSE2eNYjUFLohARIYGIGy45O0mXUHWmk91s6lN4YGjd8mbW27JZ8xOEjq6aONK2Yp21E3Fk3rjcWCCWgskpH8lHUkJqCRANMNCZBAZQJlxyepw7oDrbQea+fSG0ODxm+Ttrbdks8YHCT19NHGFbNU7XA9kKatq0m9Wm0+eyagPjotrENH2rRpkxkfH5+oHU9W4vLM/PnzJ5bxCwmQAAk0TaDuQNd00uPSG0ODxm+Ttpr+EIODpr4+2ZY9PJaiDTFOLrn6WAqtsX0yAY1NtKa/WbNmmYULFxr8KrKFBwpLgp8kQAJtEqg70MUYbDXtd+mNcTzV+G3SVsOm6VhotLVtO2/ePINXY2O2hNQlVX9MrTuGfyagMShG9lE8YMXooJEl0h0JkMAIEigem7QImj6WufTG0ODyW5bQuWzLNNS11cSjTIPGx5BtXbFI0d4YcWhKa+z2MwGNTTSCv2JnitFBI8iiCxIggREncMIJJxg8yV6cA1OKpeljWfFYCp0xNGj8NmkrjQMm58fZvfyk+dJtR8XOFbcUbY/RH/FSA9y2hzdm9akwAe1gtIodP0YH7WAzKYkESKBnBHAv+ooVK7L71KtIb/pYVjyWQnMMDRq/Llvp2VIk+pj03jVpvsuvNCZgsHLlyuzZAuk2o2ZXh6+GVYz+iPqavG9V0z6fLRNQH52W1hU7fqwO2lJzWC0JkMCACBSPT5qmNX0swxnb7du3m6NHj07IjKGhyECTKCKhxDyomMuzWIp+obUsUSzaFn35/o7BwOd/COvq8NW0P1YsmtKraVvIlgloiFAL64sdKVYHbaEprJIESGBgBIrHJ03zmj6WTZ8+3SAJxcwiKEgUcQsBltUpOAuMB0VtYot2lSWKxTNTZWc/oafI1seraKtpj8+vxs+Qbevw1XCJFYum9GraFrJlAhoi1ML6YkeK1UFbaAqrJAESGBiB4vFJ0zxf8qXxo7HN60UiiuQRtxLUKUhscVl88+bNmRvfMbr4RLXP1pXYQr+r5NvlWu9b5tPg226U1tXhq+EUKxZN6dW0LWTLBDREqIX1xY4Uq4O20BRWSQIkMDACxeOTtHm7du0ymGYOr+JssuT1xjyWavxKbTWJbZ0HT2JyaDKWTdaVj1nKemPFoim9MVkwAY1JM5KvYkeK1UEjyaMbEiCBESZQPD5JUbR1HMvrjalB47eqbeiMcfHyftdjIdXXBbt8zFLqCcVYWndTeqV6JHZMQCWUGrYpdqSYB82Gm8LqSIAEBkageHySNq+t41heb0wNGr9N2ErjALuYHDT19sk2H7NUunE/Mq4I4KG0uqUJvXU1FrdnAlok0oG/879qDxw4YA4ePGgWL17cAWWUQAIkMOoEqg50bSU9eb2xzjahD+T9htrWhK2mX4b0anwN1TYfs1RtjBmHJvTG5sAENDbRCP7wawi/ivDrKOYBM4I0uiABEhhxAlUHupiDrSYEeb0xNWj8NmGrYRKTg6bePtkuWrTIYML+/fv3J5MdMw75PpZMcGTHTEAjA43lznammB00ljb6IQESGF0C9tikJdDWsSyvN6YGjd8mbDXxiMlBU2/fbPNXI1NojxmHfB9LoTWFTyagKahG8Gk7E8+ARoBJFyRAAtEIYKqgrVu3mmPHjql8xhxsNRXbYym2ialB47cJWykTzF2KyfnrzoUqra/Pdvm4pWhHzP6I2/Rwux5u2+tLYQLa0UjZjh+zg3a0qZRFAiTQIwIzZszI3iFu58CUSm/rWGaPpdAZU4PGb942dFLB2koSRWsrjQHsMBcqkk9M+cTiJ1CFr9/j5LUx+yM8pz5jO1l9/b/YA+szTOLBdvzYHTSJWDolARIYKQL2+KRpdFvHMryhaMuWLdkZ25gaLAMkingrEs4MlxVru3v3boMEHpPTlxVrK0kUrW2ZL9fymAxc/oe0rApfTftDP0Y0vmCbWq9WT8ieCWiIUEvrbUfiwaKlALBaEiCBUgL2+FRq4FgRe7B1VOFchIRv6dKl2VuLQomi00HJQiS2OAuMf3grku+MouUlOZ5XsS2R6FzcVhycYjq+0MYilUxJf9DUnVqvRovElgmohFILNrYjxe6gLTSFVZIACQyMgD0+aZrVZuIDvU8//XQwUdS0Z+bMmWbJkiXmqaeeyi59+ra1T1Rv3LgxO0vls7WJreTYXyUOEr8+faO0rgpfDZ/YsUitV9M2iS0TUAmlFmxsR4rdQVtoCqskARIYGAF7fJI2a8+ePdn71+fPny/dJKod9CJRxGfMovGL+/MkGmxii4Q5pLfKgyccU+Q9APzBK1WJHYvUemNzYAIam2gkf7Yjxe6gkeTRDQmQwAgTsMcnKYK2j2PQK0n+pO2xdhq/qWy1D560HQvLrg+f2n6ubVPsqwKp9WrbF7IfZAKKm8IPHToUanun19uOxINFp8NEcSQwkgTs8Una+LaPY9ArOaMobY+1g19pYpvSFnylpe1YSHV2wU7bzzWad+3aZWbNmpW9dEaznc82pV5fvVXXDS4Bxdx0V155pXnrW99alUkntsOv2meeecbs27cvu4G+E6IoggRIgASeJaAd6NpOejTJnybA8CtNbGG7fv364P2iqF+jF7ZMQDVRk9tq2co9x50SzNabUq+tI+bnoBJQTMJ6zTXXmC996UsxGbXiC9N04EwuJwtuBT8rJQES8BDQDnRDTkA1Z0A1yarGlgmop7PWWIXZE3ASCLlF7JJin9Dul7HbpPU3mAT0gQceMOeee6759Kc/bfAU4RDKsmXLePZzCIFkG0hgYAS0A12KwVaDFHqliWIqvxoNWlsmoJqo6Wy1fV3qPcU+kUqrtE1au8EkoDfeeKNZs2aNeeihh8y6deu0HDppj19f+MdCAiRAAl0igIEOE6WPj4+LZKUYbEUV/8wIeqVnFLV+pYktNGBCfHyGCmwwcwBuxQoV2EoTUNyihteo+ibND9U3aus1fDVsUuwTOGmFftOXZ2AGk4Bee+215s477zSnnnqqpg902pYJaKfDQ3EkMLIEMFUQpgBCMiMpKQZbSb3WBkkEbmnCZ8xi/dlPn29rYz99tvYqniRRhD9pAopJ85GkYHJ+FhkBDV+Zx+esUu0TqfRq2ia1nSk17LqdZEf1tWHDhg3mnnvu8Zlk6w4cOGDwOrUmChJQHCxYSIAESKBrBOxAJ7lPPdVgK2UCrSiSM4pSn7CziaL99G1rOS1cuNBnlq2zx31JomjjEHT6rEHbcZBo7JqNhq9GO2Jx1llnaTYR2Vq9J510ksi+TaNeJaCHDx82SBTzBZfdMZVB3YJfhl/+8peDbnBqGzclN1E+8pGPRGlbE1pZBwmQwGgRwACH4/GLX/ziYMMx2K5evTpol8oAY8Rdd90V/Qwoxh/4lSSKp512mvnqV78qauLZZ59t7r33XpEt4oAZUyQF8062GQeJxq7Z2H4eWxdicfnll8d2a9auXSvuD69+9avNP/zDP5gXvOAF0XVIHPYqAX3sscfMGWecMaldjzzyyJRlkwyEf2CHv/XWW4PWKQ5iZZW21SnK9HA5CZAACVgCOOuHQVRS8ApKyVlCia+qNhdffHHVTUu3Q+Ip9Tt79mzzqle9qtRXfgVmQbnooovyi0q/gyv4Sgri1XYcJDq7ZANe3//+96NLShULnAGV9odvfetb2etkozdO6LBXCeiqVavMTTfdNKlp/DU3CQf/IAESIIFGCNhLfaHKcMUI919KLj2HfHH9VALgCr7gjMTVV3gJ3kfHvQ79/O6773avrLE0VSyk+yX6zPbt21ud6rFXCShuer/66qtrhJybkgAJkAAJxCAgHehwpif2vZcx9A/JB/iCc2gGmFRJz5BYFtsi7efF7UJ/p9ovoPcHP/hBqPpsFgvclzx9envPordXcxAPDUiABEiABLpKQDowM+lJH0HGIh1jKVuNAjzIjNs3QmesNT6trVRvF/ZLJqA2avwkARIgARIQE+jTQCduVE8NGYt0gZOy1ShImfxJ9abUIGXRq0vw0kbdd999UlPakQAJkAAJVCDQp4GuQvN6tQljkS5cuPUPr+LEFIxz586NUlHK5K9PfYFnQKN0JzohARIggdEi0KeBbuiRYSzSRtjeYxurFiagz5FkAhqrR9EPCZAACYwQAUxPg1dL4vWOvpJysPXVO0rrJAko4oR4cRomfc+Q8NV4TblPLFmyxOzfvz87a+vTlFKDr978OiageRr8TgIkQAIkICKAhyjwtjYkNb7ShYHOp28I6yQJEuKEeEkmzR8Ck5htkPDV1Jd6n5CcsU2tQcKDCaiEEm1IgARIgASmEJAMzF0Y6KYIH9gCxiFtQCV8NQpS7xMSvammgdJwYAKqoUVbEiABEiCBCQKSgS71YDshZoS/MA5pgy/hq1GQep+Q6E2tQcKDCaiEEm1IgARIgASmEOjLQDdF+MAWMA5pAyrhq1GQOvmT6E2tQcKDCaiEEm1IgARIgASmEAgNdJi+Bg9E4MEIlnQEJA+edCHhSEcgredQP9fWnjoWIb14IG3r1q1mxYoVWulR7ZmARsVJZyRAAiQwOgRCA10X7jMblWiEHjxJnfQMmXOon2vbnjoWIb2bN282y5Yta/2BNCag2p5DexIgARIggYxAaKBLPdAyDMcJMBbHWcT+FmKrqW/fvn3myJEjZtGiRZrNVLYhvV3ZL5mAqsJKYxIgARIgAUsgNNDxDKgllf6TsUjHOMRWU3MT+0RILxNQTcRoSwIkQAIk0DkCfRnoOgcugSDGIgHUn7nE5eo9e/aYQ4cO1a6kieSvL32BZ0Brdyc6IAESIIHRJNCXgW4UosNYpI1yiK+0diagx0kxAT3Ogt9IgARIgAQUBDAob9q0yYyPjzu3amKwdVY8ggt9CRLigzjBhqUaAR9fjccm9gmcsd29e7c5fPiwU1oTGpwVFxYyAS0A4Z8kQAIkQAIyArNmzTILFy4027Ztc27QlYHOKW5gC30JEqbcWbx4sZk5c+bAWt1cc3x8NSqa2CemTZtmVq5caVCXqzShwVVvcRkT0CIR/k0CJEACJCAm4BuYuzLQiRvTY0PGIW3wfHw1NTe1T/j0NqUhxIUJaIgQ15MACZAACZQS6MNAVyp+QCsYh7TB9PHV1NxU8ufT25SGEBcmoCFCXE8CJEACJFBKoA8DXan4Aa1gHNIG08dXU3NTyZ9Pb1MaQlyYgIYIcT0JkAAJkEApgbKBDlPWYOoaPBDBkp6A78GTriQc6Smkq6Gsn2trbCoWZXq79EAaE1Bt76E9CZAACZDABIGyga6pgXZCyIh/8T14wljU7xxl/VzrualYlOnt0gNpTEC1vYf2JEACJEACEwTKBrqmBtoJIfySTbME7sXCWBSJ6P8u6+caTwcPHjT79+83S5Ys0WxWybZMbxNvYpIKZgIqJUU7EiABEiCBKQTKBjomPVNQJV/AWKRDXMZWU2OTyV+Z3i7tl0xANb2HtiRAAiRAApMI9GGgmyR4wH8wFumCe8IJJ5gdO3aYI0eOVK6kyeSvD32BCWjlrsQNSYAESIAE+jDQjUqUGIt0kcY9titWrMjeKFW1Fiagk8kxAZ3Mg3+RAAmQAAkoCJx44okGlxaLpcnBtlj3qP7NBDRt5Mv4Smttcp/AGdvt27ebo0ePTpLXpIZJFTv+YALqgMJFJEACJEACMgJz5swxY2Nj2eXJ/BZdGujyuob83ZUgIQmZN2+eQZxY6hFw8dV4bHKfmD59ukESumnTpkkSm9QwqWLHH0xAHVC4iARIgARIQE7ANTA3+cCFXOmwLRmHtPF18dXU2PQ+4dLLBFQTMdqSAAmQAAl0mkDXB7pOw4sojnGICNPhysXXYVa6qOnkz6W3aQ2lMJ5dwTOgPjpcRwIkQAIkECTQ9YEu2ICBGDAOaQPp4qupsenkz6W3aQ0+PkxAfXS4jgRIgARIIEigONBhqpqdO3ea5cuXB7elQTwCrgdPupRwxGtpO56K/VyroulYuPQ2rcHHiAmojw7XkQAJkAAJBAkUBzoMcitXrjSYuoalOQKuB0+6lHA0RyJNTcV+rq2l6VgU9W7bts0sWLDAzJ49Wys9iT0T0CRY6ZQESIAERodAcaBreqAdHdLhljIWYUZVLYpsNX4OHTpk9uzZY5YtW6bZrJZtUW/X9ksmoLXCy41JgARIgAS6PtCNUoQYi3TRLrLV1NRG8lfU24YGHyMmoD46XEcCJEACJBAk0PWBLtiAARkwFumCiTchbd261Rw7dkxdSRvJX9f7AhNQdTfiBiRAAiRAAnkCXR/o8lqH/p2xSBfhGTNmZJfQN2/erK6ECehUZExApzLhEhIgARIgAQWB4us42xhsFXIHbVpMQJue/HzQcJ9tXJGvtL1t7BN4EHDLli0TZ2zb0ODjwwTUR4frSIAESIAEggTwqkecHdq9e3dm27WBLtiAARnkEyRMhYVXcM6dO3dALWy3KXm+GiVt7BPYJ5cuXZolodDatR8jTEA1PYi2JEACJEACTgL5gbmNwdYpagQXMg5pg57nq6mprX0ir7ctDWWcmICWkeFyEiABEiABMYEuD3TiRgzAkHFIG8Q8X01NbSV/eb1taSjjxAS0jAyXkwAJkAAJiAl0eaATN2IAhoxD2iDm+Wpqaiv5y+ttS0MZJyagZWS4nARIgARIQEzADnRHjx41eOMKpqxhaZ5A/sGTriUczdOIX6Pt51rPbcUir5f3gGqjRnsSIAESIIHOE7ADHaaowTvg8VpIluYJ5B88aSvpab7VzdVo+7m2xrZiYfXu2LHDjI2NZQ+labWnsucRIhVZ+iUBEiCBESJgB7qunWUZoRBMNJWxmEAR/Ytlq3F85MgRgwTwhBNO0GwWxdbqbSsB9jWCCaiPDteRAAmQAAmICHR5oBM1YEBGjEW6YFq2mhqQ/OHWiGnTpmk2i2Jr9TIBjYKTTkiABEiABLpGoMsDXddYpdbDWKQjDLabNm0y4+Pj4kraTP663Bd4BlTchWhIAiRAAiRQRqDLA12Z5qEuZyzSRXbmzJlm8eLF2TvhpbUwAXWTYgLq5sKlJEACJEACCgJMehSwEpvaWPB+3DSgLV+p97YTUJyxbVNDGScmoGVkuJwESIAESEBMYNGiRebw4cNm48aN2fuyxRvSMDoBJEjPPPNM9npUvCaVJS6BPiWgs2bNMgsXLjRPP/105/bLQSagx44di9vb6I0ESIAESCBI4MQTTzRPPfVU5wa6oPCBGSBBYhzSBbVPCSgodLU/DCYBfeSRR8yrX/1qg1/h+MV33nnnmbvuuitdD6RnEiABEiCBSQS6OtBNEjkCfzAOaYPcxwSUZ0AT9Qm8dePSSy/N7nG44YYbzBe+8AWDX+JXXHGFefDBBxPVSrckQAIkQAJ5Akx88jTa+844pGXfxwS0i2fEZ6YNUzPeb7/9drNhwwbz+c9/3px//vlZpS972cvMmjVrzM0332zOPffcZoSwFhIgARIYYQKY6xCv4sQnS3sEkCDhflx8ssQnAK6PPvqo2HHbDwBB7759+7ITc2LRDRgO4hI8Eszrr79+IvkEN1yKx1sHdu7c2QBGVkECJEACJLBs2bIMAl4HydIeATx4gmLj0Z6SYdaMhA5JpbS0nYDi1bgoXXsgbRAJ6Nlnn23e9ra3TeoLX//6180TTzxhcCaUhQRIgARIID0BJDyzZ89OXxFrCBKYPn26Wbp0adCOBnoCmgQUVwRwm+CKFSv0FUXaoqs/RAZxCb4Yo927d5trrrnGnH766ebNb35zcbXz74cffth85CMfca7LL9y1a5fql09+W34nARIggSETwPHx0KFDQ25ib9qG2WD27NnTG719Erpq1arsbUgSzZs3b86ST/wgaKvg8nsXS68SUNzTgns98wX3edrLDViOA+Cv/uqvmvXr15t77rlH/Gscp6gvuuiivGvn99tuu82MjY0513EhCZAACYwygQ984AMG/1jaJ6B5VWT7avulAAko5llFkh9KLLswL+673vUug39dK71KQB977DFzxhlnTGKI6Zfssq1bt2ZPwz/55JPZFExnnXXWJFvfH2vXrjVXX321zyRb9+d//ufZ/aVBQxqQAAmQAAmQAAkMjgDuccbtDVu2bAk+cNf2/Z9dht+rBBS/Om666aZJPFevXp39jXssLr744qxD3HvvveZFL3rRJDv+QQIkQAIkQAIkQAIxCNj7QEMzPjABLafdqwR08eLFzrOUOA1++eWXm+3btxs8fHTKKaeUt5hrSIAESIAESIAESKAGAZuAnnnmmV4vTEDL8fQqAS1rxo033mjuv//+7En4O++8c5IZLq0jOWUhARIgARIgARIggRgEbAIa8oUEFFdvWaYSGEQCesstt2Qtw1uQiuWyyy5jAlqEwr9JgARIgARIgAQqE9AkoJgqkmUqgUEkoLjszkICJEACJEACJEACTRDQJKCwZZlKoL2JqaZq4RISIAESIAESIAES6DwBJqD1Q8QEtD5DeiABEiABEiABEhghAkxA6webCWh9hvRAAiRAAiRAAiQwQgQkCShm6MH85G2+hrPLIWEC2uXoUBsJkAAJkAAJkEDnCEgSULyGE+9hx8T1LFMJMAGdyoRLSIAESIAESIAESKCUABLQTZs2Gd8rTzkHaCm+bAUTUD8friUBEiABEiABEiCBSQRmzZplFi5caPAWxrLCBLSMzHPLmYD6+XAtCZAACZAACZAACUwhELoMzwR0CrJJC5iATsLBP0iABEiABEiABEggTCCUgP70pz81J554YtjRiFowAR3RwLPZJEACJEACJEAC1QmEElCeAfWzZQLq58O1JEACJEACJEACJDCFABPQKUhUC5iAqnDRmARIgARIgARIgASMYQJarxcwAa3Hj1uTAAmQAAmQAAmMIAEmoPWCzgS0Hj9uTQIkQAIkQAIkMIIEmIDWCzoT0Hr8uDUJkAAJkAAJkMAIEvAloJigHm9CWrly5QiSkTWZCaiME61IgARIgARIgARIYIKALwHdsmWLWbJkiZk5c+aEPb9MJsAEdDIP/kUCJEACJEACJEACQQKY4xNzfboKp2ByUZm8jAnoZB78iwRIgARIgARIgASCBObMmWPGxsbMjh07ptgyAZ2CZMoCJqBTkHABCZAACZAACZAACYQJlF2GZwIaZscENMyIFiRAAiRAAiRAAiQwhQAT0ClIxAuYgIpR0ZAESIAESIAESIAEjhNgAnqchfYbE1AtMdqTAAmQAAmQAAmQwLMEmIBW7wZMQKuz45YkQAIkQAIkQAIjTIAJaPXgMwGtzo5bkgAJkAAJkAAJjDABJqDVg88EtDo7bkkCJEACJEACJDDCBMoSUMwPinlCWcoJMAEtZ8M1JEACJEACJEACJFBKwJWA4jWcmzZtyu4PLd2QKwwTUHYCEiABEiABEiABEqhAwJWAbtu2zSxcuNDMmjWrgsfR2YQJ6OjEmi0lARIgARIgARKISMD1Ok5OQi8DzARUxolWJEACJEACJEACJDCJwLx588yMGTPM7t27J5YzAZ1A4f3CBNSLhytJgARIgARIgARIoJxA8TI8E9ByVvk1TEDzNPidBEiABEiABEiABBQEmIAqYOVMmYDmYPArCZAACZAACZAACWgIMAHV0DpuywT0OAt+IwESIAESIAESIAEVASagKlwTxkxAJ1DwCwmQAAmQAAmQAAnoCDAB1fGy1kxALQl+kgAJkAAJkAAJkICSABNQJbCfmTMBrcaNW5EACZAACZAACZBA9sYjPPluC5+CtyT8n0xA/Xy4lgRIgARIgARIgARKCRTPgPI98KWoJq1gAjoJB/8gARIgARIgARIgATmBfAK6Y8cOMzY2ZubMmSN3MKKWTEBHNPBsNgmQAAmQAAmQQH0C+QSUl9/lPJmAylnRkgRIgARIgARIgAQmEVi0aJE5fPiw2b9/v2ECOgmN9w8moF48XEkCJEACJEACJEACfgInnniiwb2fvP/Tzym/lglonga/kwAJkAAJkAAJkICSgL0MzzOgcnBMQOWsaEkCJEACJEACJEACUwgwAZ2CJLiACWgQEQ1IgARIgARIgARIoJwAE9ByNmVrmICWkeFyEiABEiABEiABEhAQYAIqgFQwYQJaAMI/SYAESIAESIAESEBDgAmohtZztkxA9cy4BQmQAAmQAAmQAAlMEGACOoFC/IUJqBgVDUmABEiABEiABEhgKgGbgHIapqlsypYMLgEdHx8vayuXkwAJkAAJkAAJkEB0AkhAN2zYYGbNmpW9ijN6BQN0OJgE9Cc/+Yl55zvfaU4++WSDCWHf+MY3ml27dg0wZGwSCZAACZAACZBAlwggAX366acNPllkBGbKzLpvdfXVV2evwfrYxz5mDhw4YN7znveYyy67zNx3333dF0+FJEACJEACJEACvSWwdOlSc+jQIbNixYretqFp4YNIQO+8805z7733mm9961vmvPPOyxiiI1x11VXmxz/+sTnttNOa5sr6SIAESIAESIAERojAnDlzDBJRFhmBQSSgl1xyiXn88cfNqaeeOtFqvA4LBfdjsJAACZAACZAACZBASgJIPpctW5ayikH5HkQCOm3atInkc/v27eYrX/mK+dCHPmSuvPLKieWDihobQwIkQAIkQAIk0CkCSD55BlQekkEkoPnm4mzoAw88kHWC6667Lr/K+/3uu+82v/d7v+e1wcotW7aYJ554ImhHAxIgARIgARIggdEhgPs/eQ+oPN69SkAPHz6cTXOQb96aNWsmXWb/xCc+kdl8+MMfNmeddVZ2NvSCCy7Ib+L8/vKXv9x87Wtfc67LL8TT9Zdffnl+Eb+TAAmQAAmQAAmMOIF77rlnxAnomt+rBPSxxx4zZ5xxxqQWPvLII5OWYT3+XXjhhdl0TLfeequRJKBjY2PmlFNOmeTb9cfixYvNwoULXau4jARIgARIgARIgARIQECgVwnoqlWrzE033TSpWatXr86edMdDSJdeeunEOiSJSDzvv//+iWX8QgIkQAIkQAIkQAIk0D6BXiWgOPuI+T6LBfd6/tVf/ZX54Q9/ODHlEh5Gwhygv/Vbv1U0598kQAIkQAIkQAIkQAItEhjEm5Be//rXm3nz5pl3vOMd5nvf+5759re/bd70pjeZo0ePZm9HapEvqyYBEiABEiABEiABEigQ6NUZ0IL2iT/XrVtnbrvtNvPWt77VnHnmmdlyvJLz9ttvN+ecc86EHb+QAAmQAAmQAAmQAAm0T2AQCSgw4v5P3Ae6fv16M2PGDLN27dr26VIBCZAACZAACZAACZDAFAKDSUDRMkxIL3mSfQoFLiABEiABEiABEiABEmiMwCDuAW2MFisiARIgARIgARIgARKoTYAJaG2EdEACJEACJEACJEACJKAhwARUQ4u2JEACJEACJEACJEACtQkwAa2NkA5IgARIgARIgARIgAQ0BJiAamjRlgRIgARIgARIgARIoDaBQT0FX5uGwMGRI0fM1q1bzRe/+EWB9VSThx9+2DzzzDNm+fLlU1dySWcJPPbYY+Z5z3uemT6dv9k6G6SCsJ07d5qDBw+alStXFtbwzy4TeOKJJ7Jp9GbO5PDU5Tjlte3Zs8fs3r3b4HXZLP0h8NRTT5mLLroo6jHy0KFD5sCBAyII3MNFmI4b/cmf/Il5//vfb/Ba0CrlgQceMBgYFyxYUGVzbtMSgU2bNpkVK1ZkU321JIHVKgns37/fHD582CxatEi5Jc3bJLBlyxazdOnSbD7nNnWwbjkBJBz4sVd1XJTXRMuYBLZt22a++93vmtWrV0dzi5N07373u0X+po0/W0SWNIpCAMkrdtT3ve99UfzRSTMEkMRs2LDBLFy4sJkKWUttAjfccIPBFYfrr7++ti86aI4A3mz3n//5n9kVh+ZqZU11CHzuc58zn/nMZ8xnP/vZOm64bcMELrzwQnPdddeZCy64oOGan6uO1xNbwc5KSYAESIAESIAESGB0CTABHd3Ys+UkQAIkQAIkQAIk0AoBJqCtYGelJEACJEACJEACJDC6BJiAjm7s2XISIAESIAESIAESaIUAE9BWsLNSEiABEiABEiABEhhdAkxARzf2bDkJkAAJkAAJkAAJtEKACWgr2FkpCZAACZAACZAACYwuASagoxt7tpwESIAESIAESIAEWiHAiegbxv7oo4+ao0ePmhe+8IUN18zq6hC44447zCWXXMK3s9SB2PC269evz946duaZZzZcM6urQ+Duu+82L3/5y83Y2FgdN9y2QQIbN240+Hfuuec2WCurqkvgG9/4hnnxi19slixZUtdVpe2ZgFbCxo1IgARIgARIgARIgASqEuAl+KrkuB0JkAAJkAAJkAAJkEAlAkxAK2HjRiRAAiRAAiRAAiRAAlUJMAGtSo7bkQAJkAAJkAAJkAAJVCLABLQSNm5EAiRAAiRAAiRAAiRQlQAT0KrkuB0JkAAJkAAJkAAJkEAlAkxAK2HjRiRAAiRAAiRAAiRAAlUJMAGtSo7bkQAJkAAJkAAJkAAJVCLABLQSNm5EAiRAAiRAAiRAAiRQlQAT0KrkuB0JkAAJkAAJkAAJkEAlAkxAK2HjRiRAAiRAAiRAAiRAAlUJMAGtSq7iduPj4xW35GZNETh27FiwKsYxiKiTBoxb98ISikloffdaNHxFPEb2I8aHDh0yR48eLRUr2bckNqUVBFYwAQ0AirX6oYceMm94wxvM0qVLzbp168z73ve+WK7pJxKBT33qU+YlL3mJmTNnjlm2bJl57Wtfa55++ulJ3hnHSTg69cfevXvN85//fPOHf/iHU3T98z//s3nVq15l5s2bZy644AJzzz33TLHhguYIIIH567/+6yxeCxcuNK973eumxIT7WnPxkNSEmF177bVm9erVZtasWeaFL3yh+eQnPzllU+5rU5C0suDxxx/PYnXHHXdMqV8SI4nNFMfaBc9mtyyJCTw7MI4/m3SOX3XVVeMPPvjg+M033zz+7EA4/v73vz9xzXQvJfDFL34Rp6bH3/SmN40/m5yMf/zjH89iduaZZ44fPHgwc8M4Smm2Y/f2t789i+E111wzScDXvva18dmzZ49fd911488mNeNv+//27jxEimMP4PhvdUElRsVbvE9QwQMVFRQxigd4I4iCGo0ajXijCArqH57xIpBIjJEQFTxBREXBW+IR8QhiVIw33veBETz61a8e3a97d3bp3h575iXfhnW6e6u6ej5lzf66u6pm7FinZMmSzh9//BFIx0ZyAuYiwfnss8/sZ+HRo0edfv36Oeaiz3n16pU9CdpacnURtqTFixc7OTk5zvz5850TJ044o0ePtu3NBDjeIWhrHkVGV65du+aYmym2fnbu3Bk4lzB1FCZN4KBF3JAi5iNbBIE5c+Y4ZcqUcf7++28vl7n6dypWrOi8ffvW28dK5gR69Ojh1KlTxzFX+d5JbNy40TZgbYy6UI8eTdat7Nu3zwYw1apVc/IGoI0bN3bM04fAOeuH88iRIwP72EhG4P79+455yuCsXbvWK/DNmzeOuXvtmLsudh9tzaPJmpWWLVs6+jnpLu/fv3eqV6/uDB061N3l0NY8ioyt/PDDD/biztyhThmAhqmjMGnS8QZ5BB/1lnER0u/du1d69uwp5q6Ll7tv377y+PFjOXXqlLePlcwJmKt5+fHHH8Vc4XsnUbduXbv+4sUL+0o9ejRZtWLumslXX30lK1askAoVKgTqULtQXLx4Ufr37x84Z21/u3fvDuxjIxmBzZs3iz52//LLL70CS5UqJX/99ZcMGzbM7qOteTRZs6Jty/0s1JMyAYiYIFTMzRV7jrS17Kgqc4daJkyYkPLzLUwdhUmTrndKAJouyUKOox+s5koxkMLdNncDAvvZyIzAgAEDpFu3boHCN2zYILm5udK6dWu7n3oM8GTNxtSpU6VJkyZe8OI/sStXrthNt725v9PtR48eSZjBFG4eXtMjcOvWLWnatKlcvnxZTJcXad68ua07/cPnLrQ1VyJ7XseNGyemC5nMnDlTDh48aC/6TPck70KCtpYddaV9pxcuXCim21G+EwpTR2HS5DtwEXcQgBYRLkq2ly9f2jsz/jzlypWzmw8ePPDvZj1LBH777Td7R1SDG/NY154V9ZglleM7De1gr3fU9O51qkXvjuqid2/8iw4G1NGhT5488e9mPQGBu3fvytOnT+2gMA1G27RpI1u2bLEXem590NYSqIiIRehF+qRJk8T0BZUvvvhCfv31V1m+fLl3gU5biwj6iQYgcgsAAAoqSURBVJJXqlSpwCOHqaMwaQosIOIvCEAjghUluY4Y9D/a1WO42+/evSvKIcnzCQVMB3vp3bu3tGvXzo7UdYuiHl2J7Hh9/vy5jBo1SpYsWSI1a9ZMeVJ6B1sXt73lTaTTlLAkK6DB5fnz52XKlCn2TtqaNWvk9OnTohfj3377rT0Z2lqydRKmNNNnWky/XVm6dKmYAXwyY8YMO+OEGdxns9PWwihmNk2YOgqTJl3v4r+fzuk6GsdJKVC1alV59uxZ4Hf6x1MX7QvFkj0CBw4ckD59+tipenbs2BHot0s9Zk896ZlMnz7dPmZq2LChN4XP69ev7dRZZiYDewHh3r1225v7Dtz26PZfc/fz+ukFqlSpIsWKFQt0mdAuFM2aNfP6xNPWPn09RClB70zrtDxm5haZNm2azar1pd0mFi1aZPsc0taiiGYmbZg6CpMmXWdPAJouyUKOox+meft63rt3z+bQeQtZskNA+zX16tXL9gU1I+ADwaeeIfWYHfXknsW5c+dE57rr0qWLu8u+3rhxQ7Zv3y76qnWmi9ve7Ib5R9ujmYWCC0AXJMFXnUdSB2RWrlw5UKrud58I0dYCNBnf0KdC2l9aL879iw7m07lAzbQ/tDU/TJauh/k8DJMmXW+PR/DpkizkOF27dhXtq+b/RoJdu3bZ0YOtWrUqJCe/SkrgwoULNvg08xHKtm3b8gWfeh7UY1K1Ea4cM3er3Lx5M/DTqFEjO7BF99eoUcP239UBL9re/IuZG8/2Y/PvYz0ZAb1gMNMuiQY17qJfIqAXgG3btrW7aGuuTHa81qpVy56Ifk76F33SULx4cdvO9M4Zbc2vk33rYeooTJq0vbN0zOXEMQoXMJ3uHdOnyc5PaDrf24nOddLllStXFp6R3yYmYP7gOWYqGOe7776zk9DrRPTuz6VLl+x5UI+JVUeRC9L5PXWSc/+yatUqO/H81q1bHTONjLNgwQK7ffXqVX8y1hMUMN9GZb/o4eTJk44ZdeuYbx2zcyX/+eef9ixoawlWRoiidH5k801ijrlr7ZhuSo55JG+/2EHnt9YJ6d2FtuZKZP719u3bKecBDVNHYdKk4x0yEX06FEMcQ7+NQCeeN1cOdsLsMWPGODqRL0vmBfSPndZLQT9mkIR3ktSjR5GVK6kCUG1nZjYDexGodayTLLsTnmflm/gXnNTDhw8dMzeyY/qC2nank9CbuT8D75y2FuDI+IZ+TppH8PbbkLQdmTufjv4dM6OmvXOjrXkUGV8pKAANU0dh0qTjDeboQcx/JpYEBJTafTTojjRLoFiKSLMA9Zhm0IQOZ751TEzgI+7jxISKpZhCBHTQmA4Q0+4SqRbaWiqVzO7TOrtz546Yb44T841WKU+GtpaSJat2hqmjMGnivCkC0Dh65EUAAQQQQAABBBCILMAgpMhkZEAAAQQQQAABBBCII0AAGkePvAgggAACCCCAAAKRBQhAI5ORAQEEEEAAAQQQQCCOAAFoHD3yIoAAAggggAACCEQWIACNTEYGBBBAAAEEEEAAgTgCBKBx9MiLAAIIIIAAAgggEFmAADQyGRkQQAABBBBAAAEE4ggQgMbRIy8CCCCAAAIIIIBAZAEC0MhkZEAAAQQQQAABBBCII0AAGkePvAgggAACCCCAAAKRBQhAI5ORAQEEEEAAAQQQQCCOAAFoHD3yIoAAAggggAACCEQWIACNTEYGBBBAAAEEEEAAgTgCBKBx9MiLAAIIIIAAAgggEFmAADQyGRkQQAABBBBAAAEE4ggQgMbRIy8CCCCAAAIIIIBAZAEC0MhkZEAAAQQQQAABBBCII0AAGkePvAgggAACCCCAAAKRBQhAI5ORAQEEEEAAAQQQQCCOAAFoHD3yIoAAAggggAACCEQWIACNTEYGBBBAAAEEEEAAgTgCBKBx9MiLAAIIIIAAAgggEFmAADQyGRkQQAABBBBAAAEE4ggQgMbRIy8CCCCAAAIIIIBAZAEC0MhkZEAAAQQQQAABBBCII0AAGkePvAgggEBCAh8/fpRVq1bJ27dvEyqRYhBAAIFPJ0AA+ulsOTICCCCQNoHNmzfLN998Ix8+fEjbMTkQAgggkCkBAtBMyVMuAgggEEFA74CyIIAAAv8UAQLQf0pN8j4QQOD/WuDFixcyYsQIqVq1qpQvX146d+4sJ06csO9px44dMnv2bLveoUMHWbdunV1//fq1vStap04dqVixovTr109u3rzpORw/flxat24tp06dkvbt29s0gwYNkjNnznhpWEEAAQQyIUAAmgl1ykQAAQTyCEyYMEEOHjwoc+fOldWrV0uxYsWkU6dO8uTJE2nSpIl0797d5hg/fry0atVKHMeRLl26yLZt22T48OHy008/ybNnz6RNmzby9OlTm/bly5dy+vRp6dWrl2jgqWk1aO3bt689bp5TYBMBBBBITIAANDFqCkIAAQQKFjhy5IgMGTJExo4dKwMHDpT169fL0KFD5cGDB9KgQQPp2LGjzTx48GAbkG7atEl+//13+eWXX2TevHnSv39/2bNnj7x580aWLl0aKGjixIkyefJkG9BqEPru3TtZtGhRIA0bCCCAQJICuUkWRlkIIIAAAqkF2rZtK8uWLZPnz5/bO5T6CH7NmjWpE5u9R48elbJly8rnn38ux44d89I1b948sK2/0KDVXUqWLCk9evSQs2fPurt4RQABBBIXIABNnJwCEUAAgfwC+gg9NzdXfv75ZzvdUpkyZezd0AULFkjx4sXzZbhx44Zov1H3zqg/gfYJ9S81atTwb0rlypXl0KFDgX1sIIAAAkkK8Ag+SW3KQgABBAoQ0IBzw4YNtm+mPibXPp9LliyRFStWpMxRoUIFqV27tp2WSUfI+3+uXbsWyKOBqn/RfqV169b172IdAQQQSFSAADRRbgpDAAEE8gvo5PI6MEjn+ixdurQMGDDArtevX997VJ6Tk2MzutMxNW3a1I54P3nypOjv9EcHJmk/0rx9QPVxvbto/sOHD0uLFi3cXbwigAACiQsQgCZOToEIIIBAUED7ZVaqVElmzZol+/fvt6PZ9W6o3snUkfC6aF9PXXRwku7/+uuvRe+C6qh4nabp7t27MnPmTNmyZYt07drVpnX/mT59uh0Nr6PkdTCSvuqoexYEEEAgUwIEoJmSp1wEEEDAJzBnzhxp1qyZHQGv84COGTPGBpSjRo2yqXT+T71rqd+GpIOVypUrJ/v27bO/07un2s9Tg9fvv/9eWrZs6Tuy2PlBNb8eV9NokFqvXr1AGjYQQACBJAVyzCMbJ8kCKQsBBBBAoGAB/arNW7du2f6dOhdo3kVHyetjeh2w5C66Tx/j6yT2/mXv3r12xPv169elWrVq8vjxY6levbo/CesIIIBARgT+9wmWkeIpFAEEEEDAL6Aj3gsbIKR3PvMuqfblTVOiRAmCz7wobCOAQMYE8l9eZ+xUKBgBBBBAAAEEEEDg3yDwH6YZAkqS0LxeAAAAAElFTkSuQmCC" alt /><!-- --></p>
<p>Because the buffer always holds the last 5 (or fewer) elements the book-keeping involved in working with the last few elements out is simlified. Ignoring the fact that we hold the entire history in the fixed size vector <code>h</code>, only the last few elements need to be retained which may be useful if the simulation generates a lot of data.</p>
<p>A downside of this implementation is that <code>buf$read()</code> returns a list that must be turned into a vector with <code>unlist</code>, even though we know in this case that the simulation will always produce an integer vector. The ring buffers described below can help with that problem.</p>
</div>
</div>
<div id="the-bytes-buffer-ring_buffer_bytes" class="section level1">
<h1>The bytes buffer <code>ring_buffer_bytes</code></h1>
<p>This is the classical implementation of a ring buffer, and the implementation is broadly based on the one <a href="https://github.com/dhess/c-ringbuf">here</a>, by <a href="https://github.com/dhess">@dhess</a>.</p>
<p>This operates basically the same way as <code>ring_buffer_env</code>, and presents a very similar interface to R, but with a few key differences:</p>
<ul>
<li>The contents of the buffer are raw bytes (using R’s raw vectors). These are a bit fiddly to work with but can be very powerful.</li>
<li>The <code>iterate</code> distinction of <code>push</code> disappears because there is no ambiguity with R objects</li>
</ul>
<p>To construct a buffer of 1000 bytes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_bytes</span>(<span class="dv">1000</span>)</code></pre></div>
<p>Most of the same methods apply directly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">free</span>()</code></pre></div>
<pre><code>## [1] 1000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_full</span>()</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">is_empty</span>()</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Generate a byte sequence:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bytes &lt;-<span class="st"> </span><span class="kw">as.raw</span>(<span class="dv">0</span>:<span class="dv">255</span>)</code></pre></div>
<p>…and push them into the buffer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(bytes)</code></pre></div>
<p>…read from the buffer</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">read</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>##  [1] 00 01 02 03 04 05 06 07 08 09</code></pre>
<p>…destructively take the oldest elements</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 256</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">take</span>(<span class="dv">20</span>)</code></pre></div>
<pre><code>##  [1] 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 236</code></pre>
<div id="striding" class="section level2">
<h2>Striding</h2>
<p>Single bytes can hold only values 0 to 255 (or character equivalents, such as <code>a</code> becomes 61 via <code>charToRaw(&quot;a&quot;)</code>. But if you want to hold a full integer, that (usually) takes 4 bytes, a double (usually) takes 8.</p>
<p>To allow this, a bytes buffer can be “strided”; this indicates the number of consecutive bytes that should together make up one logical entry. The buffer then contains <code>size</code> of these. So to create a buffer of 100 entries, each of <code>8</code> bytes you could do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_bytes</span>(<span class="dv">100</span>, <span class="dv">8</span>)</code></pre></div>
<p>Each element pushed onto the buffer must have the correct size. So to push the byte sequence 1..8 onto the buffer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(<span class="kw">as.raw</span>(<span class="dv">1</span>:<span class="dv">8</span>))</code></pre></div>
<p>but if you pushed more or less it would be an error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(<span class="kw">as.raw</span>(<span class="dv">1</span>:<span class="dv">4</span>))</code></pre></div>
<pre><code>## Error in buf$push(as.raw(1:4)): Incorrect size data (4 bytes); expected multiple of 8 bytes</code></pre>
<p>Reading happens in <em>logical</em> units, not bytes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">read</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] 01 02 03 04 05 06 07 08</code></pre>
<p>and you can get the number of elements used:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>()</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>or the number of bytes</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">used</span>(<span class="dt">bytes =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] 8</code></pre>
</div>
<div id="the-typed-bytes-buffer-ring_buffer_bytes_typed" class="section level2">
<h2>The typed bytes buffer <code>ring_buffer_bytes_typed</code></h2>
<p>If 8 bytes is a double, it should be possible to make a bytes buffer that holds one (or more) doubles per entry. That is what the <code>ring_buffer_bytes_typed</code> buffer does, with a few corner cases dealt with. To use, you decide what the <em>R interpretation</em> of an entry is, it will determine the size per entry and appropriate encoding and decoding functions and you can ignore that it is storing bytes. For performance reasons this does not use R’s serialisation and simply copies the data stored in vectors.</p>
<p>For example, to make a buffer of 10 elements, each of which is a single real number (double), use:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_bytes_typed</span>(<span class="dv">10</span>, <span class="kw">double</span>(<span class="dv">1</span>))</code></pre></div>
<p>onto which real numbers can be pushed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(pi)</code></pre></div>
<p>And retrieve the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">take</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] 3.141593</code></pre>
<p>Entries can contain more than one number; to make a buffer of length 10, each element of which is a vector of 5 doubles:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_bytes_typed</span>(<span class="dv">10</span>, <span class="kw">double</span>(<span class="dv">5</span>))
buf$<span class="kw">push</span>(<span class="kw">rnorm</span>(<span class="dv">5</span>))
buf$<span class="kw">read</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [1]  0.26613736 -0.37670272  2.44136463 -0.79533912 -0.05487747</code></pre>
<p>Because this is just implemented as a byte array, we can just push a bunch of numbers straight into the buffer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">push</span>(<span class="kw">rnorm</span>(<span class="dv">5</span> *<span class="st"> </span><span class="dv">10</span>))</code></pre></div>
<p>With elements in the buffer, we can request them. The integer argument of <code>take</code> indicates the number of groups of 5 doubles we would like back:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">take</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>## [1]  0.2501413  0.6182433 -0.1726235 -2.2239003 -1.2636144</code></pre>
<p>If you try to take more than is in the buffer it is an error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buf$<span class="kw">take</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>## Error in super$take(n): Buffer underflow (requested 10 elements but 9 available)</code></pre>
</div>
<div id="the-translating-bytes-buffer-ring_buffer_bytes_translate" class="section level2">
<h2>The translating bytes buffer <code>ring_buffer_bytes_translate</code></h2>
<p>The <code>ring_buffer_bytes_typed</code> function is implemented by translating R objects to bytes (when storing with <code>$set()</code>, <code>$push()</code>, etc). and from bytes back to R objects (when retrieving with <code>$read()</code>, <code>$take()</code>, etc). <code>ring_buffer_bytes_translate</code> exposes this interface.</p>
<p>The “typed” buffers do not allow storing strings because they can be any number of bytes long (the bytes buffers require a fixed “stride” within a buffer). But we can store fixed length strings.</p>
<p>To convert a string to a byte sequence, use <code>charToRaw</code> (or <code>as.raw(utf8ToInt(x))</code>, but then multi-byte sequences might start being difficult).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(bytes &lt;-<span class="st"> </span><span class="kw">charToRaw</span>(<span class="st">&quot;hello world&quot;</span>))</code></pre></div>
<pre><code>##  [1] 68 65 6c 6c 6f 20 77 6f 72 6c 64</code></pre>
<p>The inverse transformation is <code>rawToChar</code> (or <code>intToUtf8(as.integer(x))</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rawToChar</span>(bytes)</code></pre></div>
<pre><code>## [1] &quot;hello world&quot;</code></pre>
<p>The function <code>ring_buffer_bytes_translate</code> takes these functions as its 3rd and fourth arguments. So to make a buffer that will hold up to 100 strings, each of 8 bytes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> </span>ring::<span class="kw">ring_buffer_bytes_translate</span>(<span class="dv">100</span>, <span class="dv">8</span>, charToRaw, rawToChar)</code></pre></div>
<p>We can now store 8 character strings:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b$<span class="kw">push</span>(<span class="st">&quot;abcdefgh&quot;</span>)
b$<span class="kw">tail</span>()</code></pre></div>
<pre><code>## [1] &quot;abcdefgh&quot;</code></pre>
<p>But other length strings cannot be added:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b$<span class="kw">push</span>(<span class="st">&quot;hello!&quot;</span>)</code></pre></div>
<pre><code>## Error in super$push(self$.to(data)): Incorrect size data (6 bytes); expected multiple of 8 bytes</code></pre>
<p>Probably this would be most useful storing just single characters as then it would make a buffer of <em>text</em>.</p>
</div>
</div>
<div id="the-c-api" class="section level1">
<h1>The C API</h1>
<p>The <code>ring</code> package can be used in other R packages using the <code>LinkingTo</code> mechanism. To do so:</p>
<ul>
<li><p>In your <code>DESCRIPTION</code>, add a line <code>LinkingTo: ring</code> (you do not need to include <code>ring</code> in <code>Depends</code> or <code>Imports</code> as we need it only for the package build).</p></li>
<li><p>In your <code>src/</code> directory, add a file <code>ring.c</code> containing just the line <code>#include &lt;ring/ring.c&gt;</code> (but see the note in the documentation for <code>ring_buffer_create</code> below).</p></li>
<li><p>Anywhere in your code you want to use the ring buffer, include the line <code>#include &lt;dde/dde.h&gt;</code> to include the prototypes and use the interface as described below.</p></li>
</ul>
<p>(I am not sure what the best practice way of doing this with a standalone shared library compiled with <code>R CMD SHLIB</code> is though; probably best to make a package.)</p>
<p>The C API is documented only in the header file, and it should be fairly straightforward to use (with reference to the docs above; this is the code underlying the <code>ring_buffer_bytes</code> interface).</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef _RING_H_</span>
<span class="ot">#define _RING_H_</span>
<span class="ot">#include &lt;stddef.h&gt;</span>
<span class="ot">#include &lt;stdbool.h&gt;</span>

<span class="ot">#ifndef RING_USE_STDLIB_ALLOC</span>
<span class="ot">#ifndef USING_R</span>
<span class="ot">#define USING_R</span>
<span class="ot">#endif</span>
<span class="ot">#endif</span>

<span class="co">// Allow use from C++</span>
<span class="ot">#ifdef __cplusplus</span>
<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
<span class="ot">#endif</span>

<span class="co">// What to do on overflow.</span>
<span class="co">//</span>
<span class="co">// The OVERFLOW_ERROR action (which calls R's error function) is only</span>
<span class="co">// available when using R, which is detected by the &lt;R.h&gt; header</span>
<span class="co">// included.  If you are using RING_USE_STDLIB_ALLOC (see below) but</span>
<span class="co">// want to use OVERFLOW_ERROR then you'll need to include &lt;R.h&gt; as</span>
<span class="co">// well, and be willing to deal with an R error and the longjmp that</span>
<span class="co">// it causes.</span>
<span class="kw">typedef</span> <span class="kw">enum</span> overflow_action {
  OVERFLOW_OVERWRITE,
  OVERFLOW_GROW
<span class="ot">#ifdef USING_R</span>
  , OVERFLOW_ERROR
<span class="ot">#endif</span>
} overflow_action;

<span class="co">// The underlying data structure.  None of the fields here should be</span>
<span class="co">// directly accessed in normal use; use the accessor functions</span>
<span class="co">// instead.</span>
<span class="co">//</span>
<span class="co">// The ring buffer is a FIFO (first-in-first-out) queue.  It is</span>
<span class="co">// implemented as a single block of memory (data) and a pair of</span>
<span class="co">// pointers:</span>
<span class="co">//</span>
<span class="co">//   head: the starting location where data should be written when</span>
<span class="co">//         copying data *into* the buffer.</span>
<span class="co">//</span>
<span class="co">//   tail: the starting location where data should be read when</span>
<span class="co">//         copying data *from* the buffer.</span>
<span class="co">//</span>
<span class="co">// The buffer has a concept of a stride; the number of bytes per</span>
<span class="co">// buffer entry.  This is fixed across the entire ring.  As such, some</span>
<span class="co">// functions that return size_t have a booleanargument &quot;bytes&quot; that</span>
<span class="co">// switches between measuring in bytes and measuring in logical</span>
<span class="co">// elements.  In the case where stride=1, these are identical.</span>
<span class="co">//</span>
<span class="co">// In general, the ring buffer is totally happy to overflow; if you</span>
<span class="co">// write too much into the ring buffer it will destructively erase</span>
<span class="co">// data (i.e., your tail will move).  The ring buffer will never</span>
<span class="co">// underflow, but functions may return `NULL` on underflow - read the</span>
<span class="co">// documentation below carefully.</span>
<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">char</span> data_t;
<span class="kw">typedef</span> <span class="kw">struct</span> ring_buffer {
  size_t size;
  size_t stride;
  size_t bytes_data;
  overflow_action on_overflow;

  data_t *data;
  data_t *head;
  data_t *tail;
} ring_buffer;

<span class="co">//// Creation, deletion, etc: ////</span>

<span class="co">// Create a ring buffer.  After creating, be sure to free the memory</span>
<span class="co">// with `ring_buffer_destroy`.</span>
<span class="co">//</span>
<span class="co">//   size: (maximum) number of elements that the ring buffer may contain</span>
<span class="co">//</span>
<span class="co">//   stride: number of *bytes* per ring buffer element</span>
<span class="co">//</span>
<span class="co">// See the note above the struct for details on size/stride.</span>
<span class="co">//</span>
<span class="co">// If the buffer cannot be allocated (e.g., too big a buffer is</span>
<span class="co">// requested) then an R error will be thrown as this uses `Calloc`.</span>
<span class="co">//</span>
<span class="co">// This may not always be desirable (e.g., if using from within C++,</span>
<span class="co">// or in a project that does not actually use R).  To use plain C</span>
<span class="co">// stdlib calloc/free, in the ring.c use:</span>
<span class="co">//</span>
<span class="co">//     #define RING_USE_STDLIB_ALLOC 1</span>
<span class="co">//     #include &lt;ring/ring.c&gt;</span>
<span class="co">//</span>
<span class="co">// which will not depend on *any* R code and use stdlib calloc/free</span>
<span class="co">// (except for the issue with USING_R/OVERFLOW_ERROR above).  With</span>
<span class="co">// RING_USE_STDLIB_ALLOC defined, if an allocation fails, then</span>
<span class="co">// ring_buffer_create (and ring_buffer_duplicate below) will return</span>
<span class="co">// NULL.  So if using this approach be sure to check the return value!</span>
<span class="co">//</span>
<span class="co">// The main wrinkle to using RING_USE_STDLIB_ALLOC 1 is that the</span>
<span class="co">// `overflow_action` `OVERFLOW_ERROR` will not work.  At present this</span>
<span class="co">// will fail to compile, but in future I may add an error handler.</span>
ring_buffer * ring_buffer_create(size_t size, size_t stride,
                                 overflow_action on_overflow);

<span class="co">// Destroy a ring buffer.  Frees the memory</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to copy; after calling this function all</span>
<span class="co">//           memory associated with the buffer is freed.</span>
<span class="dt">void</span> ring_buffer_destroy(ring_buffer *buffer);

<span class="co">// Duplicate (copy) a ring buffer.  Copies both the underlying data and</span>
<span class="co">// the position of the head and tail.  A new buffer will be allocated</span>
<span class="co">// and must be freed when finished with, using `ring_buffer_destroy`</span>
<span class="co">//</span>
<span class="co">//   buffer: a ring buffer to copy from; will not be modified</span>
ring_buffer * ring_buffer_duplicate(<span class="dt">const</span> ring_buffer *buffer);

<span class="co">// Increase the size of the ring buffer so that it can hold additional</span>
<span class="co">// elements.  This does not alter existing elements but increases the</span>
<span class="co">// capacity (similar to he `reserve` method in the C++ standard</span>
<span class="co">// library).</span>
<span class="co">//</span>
<span class="co">//   buffer: a ring buffer to increase the size of</span>
<span class="co">//</span>
<span class="co">//   n: the number of elements to increase the buffer by</span>
<span class="co">//</span>
<span class="co">//   exact: boolean, indicating if the buffer should be increased by</span>
<span class="co">//          exactly `n` elements (if true) or by at least `n` elements</span>
<span class="co">//          (if false).  If using the inexact method, the buffer is</span>
<span class="co">//          increased in size using geometric growth using the golden</span>
<span class="co">//          ratio.</span>
<span class="co">//</span>
<span class="co">// After using this function, all references to the head or tail are</span>
<span class="co">// broken and the memory may have been freed and the contents moved</span>
<span class="co">// elsewhere.</span>
<span class="co">//</span>
<span class="co">// If RING_USE_STDLIB_ALLOC is defined, and if an allocation fails,</span>
<span class="co">// then this may leave things in an undesirable state (this is</span>
<span class="co">// particularly a problem when using on_overflow = OVERFLOW_GROW).</span>
<span class="co">// Currently, if R is used an R error will be thrown (possibly not a</span>
<span class="co">// good idea if running under Rcpp) and if running as a standalone</span>
<span class="co">// application then the data will be set to NULL, probably causing a</span>
<span class="co">// crash pretty quickly (improvements welcome).</span>
<span class="dt">void</span> ring_buffer_grow(ring_buffer *buffer, size_t n, bool exact);

<span class="co">// Reset the state of the buffer.  This &quot;zeros&quot; the head and tail</span>
<span class="co">// pointer (and may or may not actually reset the data) so that the</span>
<span class="co">// buffer can be used as if fresh.</span>
<span class="co">//</span>
<span class="co">//   buffer: a ring buffer to reset</span>
<span class="co">//</span>
<span class="co">//   clear: boolean, indicating if memory should also be zeroed</span>
<span class="dt">void</span> ring_buffer_reset(ring_buffer *buffer, bool clear);

<span class="co">//// Basic querying: ////</span>

<span class="co">// Return the maximum size of the ring buffer</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to test (will not be modified)</span>
<span class="co">//</span>
<span class="co">//   bytes: indicates if size should be in bytes (if true) or elements</span>
<span class="co">//          (if false)</span>
size_t ring_buffer_size(<span class="dt">const</span> ring_buffer *buffer, bool bytes);

<span class="co">// Report the free and used space in the ring buffer</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to test (will not be modified)</span>
<span class="co">//</span>
<span class="co">//   bytes: indicates if used/free space should be in bytes (if true)</span>
<span class="co">//          or elements (if false)</span>
size_t ring_buffer_free(<span class="dt">const</span> ring_buffer *buffer, bool bytes);
size_t ring_buffer_used(<span class="dt">const</span> ring_buffer *buffer, bool bytes);

<span class="co">// Report the number of bytes of data that have been allocated.  Note</span>
<span class="co">// that this is likely `stride` more bytes than was requested as this</span>
<span class="co">// avoids a lot of awkward bookkeeping later, allowing the &quot;full&quot;</span>
<span class="co">// state to be distinguished from the &quot;empty&quot; state.</span>
size_t ring_buffer_bytes_data(<span class="dt">const</span> ring_buffer *buffer);

<span class="co">// Report if the ring buffer is full or empty</span>
bool ring_buffer_is_full(<span class="dt">const</span> ring_buffer *buffer);
bool ring_buffer_is_empty(<span class="dt">const</span> ring_buffer *buffer);

<span class="co">//// Additional querying: ////</span>

<span class="co">// Return the position of the head and tail pointers relative to the</span>
<span class="co">// data pointer (this is an offset, so 0 means the pointer is at the</span>
<span class="co">// start of the data array).</span>
<span class="co">//</span>
<span class="co">//   bytes: indicates if offset should be bytes (if true) or elements (if false)</span>
size_t ring_buffer_head_pos(<span class="dt">const</span> ring_buffer *buffer, bool bytes);
size_t ring_buffer_tail_pos(<span class="dt">const</span> ring_buffer *buffer, bool bytes);

<span class="co">// Return pointers to the the data, head and tail members of the ring</span>
<span class="co">// buffer.  These are preferred over directly accessing the &quot;data&quot;,</span>
<span class="co">// &quot;head&quot; and &quot;tail&quot; elements of the ring buffer structure itself</span>
<span class="co">// because with these the compiler will enforce read-only access for</span>
<span class="co">// you.</span>
<span class="co">//</span>
<span class="co">// WARNING: the head buffer is *not* the most recently added element,</span>
<span class="co">// but instead the bit of memory that will be written to next; it's</span>
<span class="co">// generally not terribly useful and a better way of getting the last</span>
<span class="co">// written element is to use:</span>
<span class="co">//</span>
<span class="co">//   ring_buffer_head_offset(buffer, 0);</span>
<span class="co">//</span>
<span class="co">// which will look after wrapping the ring buffer appropriately.</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_data(<span class="dt">const</span> ring_buffer *buffer);
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_head(<span class="dt">const</span> ring_buffer *buffer);
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_tail(<span class="dt">const</span> ring_buffer *buffer);

<span class="co">//// Setting repeated values: ////</span>

<span class="co">// Set all bytes of a length of the buffer to 'c'.  Here, 'len' is the</span>
<span class="co">// number of *entries*, so stride * len bytes will be set.  This will</span>
<span class="co">// mostly be uesful with c=0.</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to set data into</span>
<span class="co">//</span>
<span class="co">//   c: value (0-255) to set all bytes to</span>
<span class="co">//</span>
<span class="co">//   n: number of elements to set</span>
<span class="co">//</span>
<span class="co">// This starts adding data at `head`.  If the buffer will overflow, at</span>
<span class="co">// most `bytes_data` bytes will be written (i.e., each element will be</span>
<span class="co">// written to once).</span>
<span class="co">//</span>
<span class="co">// Returns the number of bytes actually written to the buffer (so if</span>
<span class="co">// the buffer overflows this may be less than `len`).</span>
size_t ring_buffer_set(ring_buffer *buffer, data_t c, size_t n);

<span class="co">// Set a number of the elements of the buffer to a particular byte</span>
<span class="co">// pattern.  In contrast with `ring_buffer_set`, this does not set</span>
<span class="co">// individual bytes, but instead complete elements.</span>
<span class="co">//</span>
<span class="co">//    buffer: the ring buffer to set data into</span>
<span class="co">//</span>
<span class="co">//    x: pointer to a set of data to copy into the ring buffer.  This</span>
<span class="co">//            must be (at least) stride bytes long.</span>
<span class="co">//</span>
<span class="co">//    n: number of elements to set</span>
<span class="co">//</span>
<span class="co">// This starts adding data at `head`.  If the buffer will overflow, at</span>
<span class="co">// most `bytes_data` bytes will be written (i.e., each element will be</span>
<span class="co">// written to once).</span>
size_t ring_buffer_set_stride(ring_buffer *buffer, <span class="dt">const</span> <span class="dt">void</span> *x, size_t n);

<span class="co">//// Read and write ////</span>

<span class="co">// Copy `n` entries, each of `stride` bytes from a contiguous memory</span>
<span class="co">// area src into the ring `buffer`. Returns the ring buffer's new head</span>
<span class="co">// pointer.</span>
<span class="co">//</span>
<span class="co">// It is possible to overflow the buffer with this function</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to copy data into</span>
<span class="co">//</span>
<span class="co">//   src: the source memory to copy from (make sure this is big enough</span>
<span class="co">//           or you will get crashes and other terrible things).</span>
<span class="co">//</span>
<span class="co">//   n: the number of entries to copy from `src` into `buffer` (each</span>
<span class="co">//           of which is `stride` bytes long).</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_push(ring_buffer *buffer, <span class="dt">const</span> <span class="dt">void</span> *src, size_t n);

<span class="co">// Destructively copy `n` entries (each of which is `stride` bytes)</span>
<span class="co">// from a ring buffer `buffer` into contiguous memory region `dest`.</span>
<span class="co">// This updates the `tail` pointers in the ring buffer and returns the</span>
<span class="co">// new tail pointer.</span>
<span class="co">//</span>
<span class="co">// The `n` entries will no longer be available in the ring buffer.</span>
<span class="co">// To do a nondestructive read, use `ring_buffer_read()`.</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to copy data from</span>
<span class="co">//</span>
<span class="co">//   dest: the destination memory to copy into (make sure this is big enough</span>
<span class="co">//           or you will get crashes and other terrible things).</span>
<span class="co">//</span>
<span class="co">//   n: the number of entries to copy from `src` into `buffer` (each</span>
<span class="co">//           of which is `stride` bytes long).</span>
<span class="co">//</span>
<span class="co">// This function will not allow the ring buffer to underflow.  If</span>
<span class="co">// `n` is greater than the number of available entries, then</span>
<span class="co">// nothing is copied (and the ring buffer remains unmodified) and NULL</span>
<span class="co">// is returned.</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_take(ring_buffer *buffer, <span class="dt">void</span> *dest, size_t n);

<span class="co">// Nondestructively read from a ring buffer.  This function is</span>
<span class="co">// essentially identical to `ring_buffer_take` but does not alter the</span>
<span class="co">// tail pointer.</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_read(<span class="dt">const</span> ring_buffer *buffer, <span class="dt">void</span> *dest, size_t n);

<span class="co">// ring_buffer_take_head and ring_buffer_read_head are like</span>
<span class="co">// ring_buffer_take and ring_buffer_read (respectively) but operate on</span>
<span class="co">// the *head* of the ring (i.e., removing the most recently added</span>
<span class="co">// elements rather than the oldest elements).</span>
<span class="co">//</span>
<span class="co">// Neither will underflow, returning NULL if there are not enough</span>
<span class="co">// elements, and without copying anything.</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_take_head(ring_buffer *buffer, <span class="dt">void</span> *dest, size_t n);
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_read_head(<span class="dt">const</span> ring_buffer *buffer, <span class="dt">void</span> *dest,
                                   size_t n);

<span class="co">// Copy `n` entries (each of `stride` bytes) from one ring buffer</span>
<span class="co">// `src` into another `dest`.  The copy starts at the tail of this</span>
<span class="co">// ring buffer, pushing onto the head of the destination buffer.</span>
<span class="co">//</span>
<span class="co">//   src: A ring buffer to copy data from</span>

<span class="co">//   dest: A ring buffer to copy data into</span>
<span class="co">//</span>
<span class="co">//   n: the number of entries to copy (each of which is `stride` bytes)</span>
<span class="co">//</span>
<span class="co">// This is destructive to both buffers as pointers will be updated in</span>
<span class="co">// both.</span>
<span class="co">//</span>
<span class="co">// This function returns the new head pointer of the destination buffer.</span>
<span class="co">//</span>
<span class="co">// It is not possible to underflow `src`; if too few entries are</span>
<span class="co">// available, then nothing is copied, `src` and `dest` are not</span>
<span class="co">// modified, and the function returns NULL</span>
<span class="co">//</span>
<span class="co">// It is possible to overflow `dest` and the tail pointer will be</span>
<span class="co">// updated appropriately if so.</span>
<span class="co">//</span>
<span class="co">// Warning: the two buffers must have the same stride.  If the buffers</span>
<span class="co">// do not have the same stride, the function will return NULL (this</span>
<span class="co">// means if the function returns NULL it could either be an underflow</span>
<span class="co">// or an incompatible buffer).</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_copy(ring_buffer *src, ring_buffer *dest, size_t n);

<span class="co">// Mirror the contents of ring buffer `src` into ring buffer `dest`.</span>
<span class="co">// This differs from `ring_buffer_copy` in that the `src` buffer is</span>
<span class="co">// not modified and that the *entire* state of the ring buffer is</span>
<span class="co">// duplicated.</span>
<span class="co">//</span>
<span class="co">// The function requires (and checks) that `src` and `dest` agree on</span>
<span class="co">// size and stride (and therefore total bytes).  It returns `true` if</span>
<span class="co">// the mirror was done, and `false` if the buffers are incompatible.</span>
<span class="co">//</span>
<span class="co">// This function will destroy all data in `dest`, but not allocate any</span>
<span class="co">// memory.</span>
<span class="co">//</span>
<span class="co">// Warning: the two buffers must have the same stride *and* the same</span>
<span class="co">// size.  If they do not, the function will return NULL (this means if</span>
<span class="co">// the function returns NULL it could either be an underflow or an</span>
<span class="co">// incompatible buffer).</span>
bool ring_buffer_mirror(<span class="dt">const</span> ring_buffer *src, ring_buffer *dest);

<span class="co">// Returns a pointer to the tail (reading end) of the buffer, offset</span>
<span class="co">// by `offset` entries.  When used as `ring_buffer_tail_offset(x, 0)`</span>
<span class="co">// this is equivalent to `ring_buffer_tail(x)` except that it will do</span>
<span class="co">// underflow checking.</span>
<span class="co">//</span>
<span class="co">//   buffer: the ring buffer to use</span>
<span class="co">//</span>
<span class="co">//   offset: the number of entries (each of which are `stride` bytes)</span>
<span class="co">//           to offset by</span>
<span class="co">//</span>
<span class="co">// It is not possible to underflow the buffer here; if `offset` is so</span>
<span class="co">// large that it would underflow, then NULL will be returned.</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_tail_offset(<span class="dt">const</span> ring_buffer *buffer, size_t offset);

<span class="co">// As for `ring_buffer_tail_offset`, but offsetting the *head*</span>
<span class="co">// pointer.  This offsets in the opposite direction (moving from the</span>
<span class="co">// most recently added element towards the oldest element).</span>
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_head_offset(<span class="dt">const</span> ring_buffer *buffer, size_t offset);

<span class="co">//// For advanced use: ////</span>

<span class="co">// Advance the ring buffer by one entry and return a pointer to the</span>
<span class="co">// memory *without writing anything to it*.  In this case, the calling</span>
<span class="co">// function is responsible for setting the memory to something</span>
<span class="co">// sensible.  This is currently used in the dde package where we want</span>
<span class="co">// to write directly to the head.</span>
<span class="co">//</span>
<span class="co">// This is (roughly) equivalent to:</span>
<span class="co">//</span>
<span class="co">//    ring_buffer_set(buffer, 0, 1);</span>
<span class="co">//    return buffer-&gt;head;</span>
<span class="co">//</span>
<span class="co">// but does not actually copy any data.</span>
<span class="co">//</span>
<span class="co">// Note that the pointer returned is *not* const; this is always used</span>
<span class="co">// in a case where the aim is to write to the head directly!</span>
<span class="dt">void</span> * ring_buffer_head_advance(ring_buffer *buffer);

<span class="co">//// Search: ////</span>

<span class="co">// There are two functions for searching for data within a ring buffer</span>
<span class="co">// that consists of *sorted* entries.  This might be the case if</span>
<span class="co">// entries are added sequentially with (say) a timestamp.</span>
<span class="co">//</span>
<span class="co">// To locate an entry, a predicate function (pointer) must be</span>
<span class="co">// provided.  This must be a function taking two void pointers as</span>
<span class="co">// arguments; the first will be the pointer to an entry in the ring</span>
<span class="co">// buffer, the second will be any data that *you* provide (may be</span>
<span class="co">// NULL).  This function must return &quot;true&quot; if the value is *less</span>
<span class="co">// than* the target value (i.e. true if we should search *earlier* in</span>
<span class="co">// the buffer).  The &quot;x&quot; argument must be treated as read-only.</span>
<span class="co">//</span>
<span class="co">// For example, a predictate function that would find an entry where</span>
<span class="co">// the first 8 bytes of a ring buffer entry represent doubles could be</span>
<span class="co">// written as:</span>
<span class="co">//</span>
<span class="co">//     bool test_find_double(const void *x, void *data) {</span>
<span class="co">//       double x_value = *((double*) x);</span>
<span class="co">//       double data_value = *((double*) data);</span>
<span class="co">//       return x_value &lt;= data_value;</span>
<span class="co">//     }</span>
<span class="co">//</span>
<span class="co">// Where the &quot;data&quot; argument will be passed through as the number to</span>
<span class="co">// search for.</span>
<span class="co">//</span>
<span class="co">// These functions return NULL if no entry is found, otherwise they</span>
<span class="co">// return the pointer to the largest entry in the buffer that the</span>
<span class="co">// predicate returns false.</span>
<span class="co">//</span>
<span class="co">// The _linear search does a naive linear search from the tail of the</span>
<span class="co">// buffer (i.e., the last entry that was added) towards the beginning.</span>
<span class="co">//</span>
<span class="co">// The _bisect search tries to be more clever and does a bisect</span>
<span class="co">// search.  It requires an initial guess &quot;i&quot; to the location of the</span>
<span class="co">// data.  You can provide '0' as 'i' to start at the tail.</span>
<span class="co">//</span>
<span class="co">// The &quot;data&quot; argument to both functions will be passed through to the</span>
<span class="co">// predicate function.</span>
<span class="kw">typedef</span> bool ring_predicate(<span class="dt">const</span> <span class="dt">void</span> *x, <span class="dt">void</span> *data);
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_search_linear(<span class="dt">const</span> ring_buffer *buffer,
                                       ring_predicate pred, <span class="dt">void</span> *data);
<span class="dt">const</span> <span class="dt">void</span> * ring_buffer_search_bisect(<span class="dt">const</span> ring_buffer *buffer, size_t i,
                                       ring_predicate pred, <span class="dt">void</span> *data);

<span class="ot">#ifdef __cplusplus</span>
}
<span class="ot">#endif</span>
<span class="ot">#endif</span></code></pre></div>
<p>For a complete real-world example of use, see <a href="https://github.com/richfitz/dde">dde</a>, which uses a ring buffer to hold the history of a set of differential equations, and uses that to implement delay equations. Here, the ring buffer means that the memory requirements don’t grow with the length of running the simulation (as it only cares about fairly recent history, the natural overflow from the ring buffer is well suited). The memory is only allocated at the beginning of the simulation so there is no additional memory allocations. And because <code>ring</code> returns (const) pointers to the appropriate place in memory there is little copying.</p>
<p>A simple application that implements the same mean-reverting simulation from above:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;ring/ring.h&gt;</span>

<span class="ot">#include &lt;R.h&gt;</span>
<span class="ot">#include &lt;Rinternals.h&gt;</span>

<span class="co">// Definition used below (can't be called step() because that may</span>
<span class="co">// conflict with regexp.h on some platforms).</span>
<span class="dt">int</span> step_x(ring_buffer *r, <span class="dt">int</span> x);

<span class="dt">void</span> example(size_t nstep, <span class="dt">double</span> *ret) {
  <span class="co">// Construct a ring buffer of (max) size 5, each element of which is</span>
  <span class="co">// big enough to contain an integer (probably 4 bytes).</span>
  ring_buffer *r = ring_buffer_create(<span class="dv">5</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>), OVERFLOW_OVERWRITE);

  <span class="co">// Starting point of the simulation, as in the R version:</span>
  <span class="dt">int</span> x = <span class="dv">0</span>;

  <span class="co">// Push the initial state into the ring buffer:</span>
  ring_buffer_push(r, &amp;x, <span class="dv">1</span>);
  ret[<span class="dv">0</span>] = x;

  <span class="kw">for</span> (size_t i = <span class="dv">1</span>; i &lt; nstep; ++i) {
    x = step_x(r, x);
    ring_buffer_push(r, &amp;x, <span class="dv">1</span>);
    ret[i] = x;
  }

  <span class="co">// Cleanup:</span>
  ring_buffer_destroy(r);
}

<span class="dt">int</span> step_x(ring_buffer *r, <span class="dt">int</span> x) {
  size_t n = ring_buffer_used(r, false);
  <span class="dt">double</span> p;
  <span class="kw">if</span> (n &lt; <span class="dv">2</span>) {
    p = <span class="fl">0.5</span>;
  } <span class="kw">else</span> {
    <span class="co">// Oldest non-overflowed element is in the tail.  Note that the</span>
    <span class="co">// return value (which is void*) must be first cast to (int*) then</span>
    <span class="co">// dereferenced.</span>
    <span class="co">///</span>
    <span class="co">// NOTE: In general, check that the return value here is not NULL</span>
    <span class="co">// (indicating an underflow); here we're OK because we checked the</span>
    <span class="co">// number of used elements at the beginning.</span>
    <span class="dt">int</span> x0 = *(<span class="dt">int</span>*)ring_buffer_tail(r);
    size_t increases = <span class="dv">0</span>;
    <span class="kw">for</span> (size_t i = <span class="dv">1</span>; i &lt; n; ++i) {
      <span class="co">// Moving through the more recently added elements:</span>
      <span class="dt">int</span> x1 = *(<span class="dt">int</span>*)ring_buffer_tail_offset(r, i);
      <span class="kw">if</span> (x1 &gt; x0) {
        increases++;
      }
      x0 = x1;
    }
    p = ((<span class="dt">double</span>)increases) / (n - <span class="dv">1</span>);
  }

  <span class="kw">if</span> (unif_rand() &lt; p) {
    --x;
  } <span class="kw">else</span> {
    ++x;
  }

  <span class="kw">return</span> x;
}

<span class="co">// This function collects all the R API bits that deal with</span>
<span class="co">// communication between C and R.  &quot;Writing R extensions&quot; is the</span>
<span class="co">// canonical documentation source.</span>
SEXP r_example(SEXP r_nstep) {
  size_t nstep = (size_t) INTEGER(r_nstep)[<span class="dv">0</span>];
  SEXP ret = PROTECT(allocVector(REALSXP, nstep));
  GetRNGstate(); <span class="co">// because we'll work with random numbers</span>
  example(nstep, REAL(ret));
  <span class="co">// Cleanup:</span>
  PutRNGstate();
  UNPROTECT(<span class="dv">1</span>);
  <span class="kw">return</span> ret;
}

<span class="co">// This can be included in a different file, or, for a single file</span>
<span class="co">// project like this one, include here.</span>
<span class="ot">#include &lt;ring/ring.c&gt;</span></code></pre></div>
<div id="a-nontrivial-example" class="section level2">
<h2>A nontrivial example</h2>
<p>In the <a href="https://github.com/richfitz/dde"><code>dde</code></a> package (not yet on CRAN), I use ring buffers to solve delay differential equations (DDEs). To solve these, we need to know the state of the system at a series of points in the past. So at every time step we push the state of the system onto a ring buffer. Then, as the solver moves forward in time we can get the system at some previous point in time by looking back through the ring buffer until the time in question is found.</p>
<p>In this application a ring buffer is the ideal data structure because we often want to solve equations where the time we look back is a small fraction of the total time. Without a ring buffer we’d either have to store the <em>entire</em> history (with a large memory cost, most of which is not needed) or periodically copy the history around.</p>
<p>To use <code>ring</code> within the <code>dde</code> package:</p>
<ul>
<li><p>In the <code>DESCRIPTION</code> we <a href="https://github.com/richfitz/dde/blob/7ebaefd/DESCRIPTION#L14">declare a link to <code>ring</code></a> using the <code>LinkingTo:</code> field.</p></li>
<li><p>In the <code>src</code> directory, <a href="https://github.com/richfitz/dde/blob/7ebaefd/src/ring.c">the contents of <code>&lt;ring/ring.c&gt;</code> are included</a>; this is possible because of the <code>LinkingTo</code> field. This file now includes all the actual ring buffer implementation.</p></li>
<li><p>In <a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.h#L8">src/dopri.h</a> we include <code>&lt;ring/ring.h&gt;</code> which allows the ring buffer code to be used in any file that includes <code>dopri.h</code>. There is a <a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.h#L77-L111">data structure in this header</a> that includes within itself a ring buffer to hold the history.</p></li>
<li><p>In <a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.c">src/dopri.c</a> the ring buffer code is actually used:</p>
<ul>
<li><a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.c#L48-L50">initialisation</a></li>
<li><a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.c#L694-L719">a time is found within the ring buffer</a></li>
<li><a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.c#L417">the ring buffer is advanced</a></li>
<li><a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri.c#L220">the data is freed</a></li>
</ul></li>
<li><p>In <a href="https://github.com/richfitz/dde/blob/7ebaefd/src/dopri_5.c#L109-L119">src/dopri_5.c</a> new data is written to the head of the ring buffer, being the state of the system at the end of the step. The history head is treated as a big block of contiguous doubles.</p></li>
</ul>
<p>Used this way, the programmer can focus on simply writing to the application and do as little work on bookkeeping as possible.</p>
</div>
</div>
<div id="the-c-api-1" class="section level1">
<h1>The C++ API</h1>
<p>If you’re using C++ you may find the <a href="http://www.boost.org/doc/libs/1_61_0/doc/html/circular_buffer.html">Boost circular buffer</a> is likely to be far better; you can use this by <code>LinkingTo:</code> the <code>BH</code> package and using <code>#include &lt;boost/circular_buffer.hpp&gt;</code> in your code.</p>
<p>Alternatively, the <code>ring</code> C code can be directly used in C++ as above. Or, there is a class-based approach available:</p>
<ul>
<li><p>In your <code>src/</code> directory, add a file <code>ring.cpp</code> containing just the line <code>#include &lt;ring/ring.cpp&gt;</code></p></li>
<li><p>Anywhere in your code you want to use the ring buffer, include the line <code>#include &lt;dde/dde.hpp&gt;</code> to include the class definition:</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _RING_HPP_</span>
<span class="ot">#define _RING_HPP_</span>

<span class="co">// NOTE: the C++ version always uses non-R memory allocation functions</span>
<span class="co">// because otherwise the R error can jump over destructors causing</span>
<span class="co">// memory leaks or worse.  Errors will be thrown with &quot;throw&quot;, which</span>
<span class="co">// Rcpp will catch if you use that.</span>
<span class="co">//</span>
<span class="co">// However, note that if using overflow_action of anything other than</span>
<span class="co">// OVERFLOW_OVERWRITE is possibly unsafe; OVERFLOW_GROW is fine so</span>
<span class="co">// long as you never run out of memory, and OVERFLOW_ERROR is probably</span>
<span class="co">// never safe.</span>
<span class="ot">#define RING_USE_STDLIB_ALLOC 1</span>
<span class="ot">#include &lt;ring/ring.h&gt;</span>

<span class="kw">class</span> RingBuffer {
  ring_buffer * buffer;
<span class="kw">public</span>:
  RingBuffer(size_t size, size_t stride, overflow_action on_overflow);
  ~RingBuffer();
  RingBuffer(<span class="dt">const</span> RingBuffer&amp; other);
  RingBuffer&amp; <span class="kw">operator</span>=(RingBuffer other);

  <span class="dt">void</span> grow(size_t n, <span class="dt">bool</span> exact);
  <span class="dt">void</span> reset(<span class="dt">bool</span> clear);
  size_t size(<span class="dt">bool</span> bytes) <span class="dt">const</span>;
  size_t free(<span class="dt">bool</span> bytes) <span class="dt">const</span>;
  size_t used(<span class="dt">bool</span> bytes) <span class="dt">const</span>;
  size_t bytes_data() <span class="dt">const</span>;
  <span class="dt">bool</span> is_full() <span class="dt">const</span>;
  <span class="dt">bool</span> is_empty() <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * data() <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * head() <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * tail() <span class="dt">const</span>;
  size_t head_pos(<span class="dt">bool</span> bytes) <span class="dt">const</span>;
  size_t tail_pos(<span class="dt">bool</span> bytes) <span class="dt">const</span>;
  size_t set(data_t c, size_t len);
  size_t set_stride(<span class="dt">const</span> <span class="dt">void</span> *x, size_t len);
  <span class="dt">const</span> <span class="dt">void</span> * push(<span class="dt">const</span> <span class="dt">void</span> *src, size_t n);
  <span class="dt">const</span> <span class="dt">void</span> * take(<span class="dt">void</span> *dest, size_t n);
  <span class="dt">const</span> <span class="dt">void</span> * read(<span class="dt">void</span> *dest, size_t n) <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * copy(RingBuffer&amp; dest, size_t n);
  <span class="dt">bool</span> mirror(RingBuffer&amp; dest) <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * tail_offset(size_t offset) <span class="dt">const</span>;
  <span class="dt">const</span> <span class="dt">void</span> * head_offset(size_t offset) <span class="dt">const</span>;
};

<span class="ot">#endif</span></code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
